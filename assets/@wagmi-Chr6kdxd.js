const __vite__fileDeps=["assets/@walletconnect-JjN6c9yP.js","assets/@stablelib-B519yloO.js","assets/@babel-VbPd-4M3.js","assets/multiformats-DSKVg-N-.js","assets/events-BHFBkAHP.js","assets/detect-browser-ClY_l-h2.js","assets/tslib-CoNcODE4.js","assets/query-string-SCOpAa9y.js","assets/strict-uri-encode-DdzwWRIL.js","assets/decode-uri-component-CROxjmim.js","assets/split-on-first-BNP3K2Fc.js","assets/filter-obj-DG2z_hf8.js","assets/uint8arrays-BSAB2j_x.js","assets/unstorage-I5IaDmqs.js","assets/destr-CVtkxrq9.js","assets/idb-keyval-nibyPLVP.js","assets/pino-Cra013RC.js","assets/quick-format-unescaped-Dys6CG9o.js","assets/lodash.isequal-cb4NOOgA.js","assets/isomorphic-unfetch-DzflogNS.js","assets/unfetch-D6v4VzSN.js","assets/cross-fetch-aPGaTLN9.js","assets/@lit-DjZwrzog.js","assets/lit-html-DfFMVDgK.js","assets/lit-element-Cx71in3k.js","assets/valtio-CyFKDiGU.js","assets/proxy-compare-DDw08AJZ.js","assets/qrcode-CGiDONbL.js","assets/encode-utf8-Cn5aGd7v.js","assets/dijkstrajs-D_NXgYpA.js","assets/motion-NW9MFZdV.js","assets/@motionone-BkHL0rzb.js","assets/zustand-CsM-6wGT.js","assets/viem-DwhbZOjf.js","assets/eventemitter3-1nPwmqHx.js","assets/mipd-CIcDX0W7.js","assets/@vue-COkQ5Dd_.js","assets/@tanstack-CY-Q3uP3.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{c as Y,s as Ue,p as Re}from"./zustand-CsM-6wGT.js";import{g as k,U as q,R as ee,w as Ee,a as De,S as re,n as F,c as we,p as Ke,b as xe,d as We,m as Le,r as Be,C as be,h as Te,t as Fe,f as Ce,e as Qe,s as ze,i as Ve}from"./viem-DwhbZOjf.js";import{E as He}from"./eventemitter3-1nPwmqHx.js";import{c as Je}from"./mipd-CIcDX0W7.js";import{u as Q,h as Ge,i as Ze,b as Xe,t as Ye,d as ie,o as D,a as ve,c as j,r as H,x as et}from"./@vue-COkQ5Dd_.js";import{r as tt,u as nt,a as rt,b as ae}from"./@tanstack-CY-Q3uP3.js";const st="modulepreload",ot=function(e){return"/hackaton/"+e},he={},ct=function(n,t,r){let s=Promise.resolve();if(t&&t.length>0){document.getElementsByTagName("link");const o=document.querySelector("meta[property=csp-nonce]"),i=(o==null?void 0:o.nonce)||(o==null?void 0:o.getAttribute("nonce"));s=Promise.all(t.map(l=>{if(l=ot(l),l in he)return;he[l]=!0;const u=l.endsWith(".css"),c=u?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${l}"]${c}`))return;const f=document.createElement("link");if(f.rel=u?"stylesheet":st,u||(f.as="script",f.crossOrigin=""),f.href=l,i&&f.setAttribute("nonce",i),document.head.appendChild(f),u)return new Promise((d,a)=>{f.addEventListener("load",d),f.addEventListener("error",()=>a(new Error(`Unable to preload CSS for ${l}`)))})}))}return s.then(()=>n()).catch(o=>{const i=new Event("vite:preloadError",{cancelable:!0});if(i.payload=o,window.dispatchEvent(i),!i.defaultPrevented)throw o})};class it{constructor(n){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new He})}on(n,t){this._emitter.on(n,t)}once(n,t){this._emitter.once(n,t)}off(n,t){this._emitter.off(n,t)}emit(n,...t){const r=t[0];this._emitter.emit(n,{uid:this.uid,...r})}listenerCount(n){return this._emitter.listenerCount(n)}}function at(e){return new it(e)}function ut(e,n){return JSON.parse(e,(t,r)=>{let s=r;return(s==null?void 0:s.__type)==="bigint"&&(s=BigInt(s.value)),(s==null?void 0:s.__type)==="Map"&&(s=new Map(s.value)),(n==null?void 0:n(t,s))??s})}function pe(e,n){return e.slice(0,n).join(".")||"."}function ye(e,n){const{length:t}=e;for(let r=0;r<t;++r)if(e[r]===n)return r+1;return 0}function lt(e,n){const t=typeof e=="function",r=typeof n=="function",s=[],o=[];return function(l,u){if(typeof u=="object")if(s.length){const c=ye(s,this);c===0?s[s.length]=this:(s.splice(c),o.splice(c)),o[o.length]=l;const f=ye(s,u);if(f!==0)return r?n.call(this,l,u,pe(o,f)):`[ref=${pe(o,f)}]`}else s[0]=u,o[0]=l;return t?e.call(this,l,u):u}}function dt(e,n,t,r){return JSON.stringify(e,lt((s,o)=>{let i=o;return typeof i=="bigint"&&(i={__type:"bigint",value:o.toString()}),i instanceof Map&&(i={__type:"Map",value:Array.from(o.entries())}),(n==null?void 0:n(s,i))??i},r),t??void 0)}function ft(e){const{deserialize:n=ut,key:t="wagmi",serialize:r=dt,storage:s=Ie}=e;function o(i){return i instanceof Promise?i.then(l=>l).catch(()=>null):i}return{...s,key:t,async getItem(i,l){const u=s.getItem(`${t}.${i}`),c=await o(u);return c?n(c)??null:l??null},async setItem(i,l){const u=`${t}.${i}`;l===null?await o(s.removeItem(u)):await o(s.setItem(u,r(l)))},async removeItem(i){await o(s.removeItem(`${t}.${i}`))}}}const Ie={getItem:()=>null,setItem:()=>{},removeItem:()=>{}};const B="2.10.4",ht=()=>`@wagmi/core@${B}`;var Se=function(e,n,t,r){if(t==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof n=="function"?e!==n||!r:!n.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?r:t==="a"?r.call(e):r?r.value:n.get(e)},z,_e;let E=class se extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return ht()}constructor(n,t={}){var o;super(),z.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});const r=t.cause instanceof se?t.cause.details:(o=t.cause)!=null&&o.message?t.cause.message:t.details,s=t.cause instanceof se&&t.cause.docsPath||t.docsPath;this.message=[n||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...s?[`Docs: ${this.docsBaseUrl}${s}.html${t.docsSlug?`#${t.docsSlug}`:""}`]:[],...r?[`Details: ${r}`]:[],`Version: ${this.version}`].join(`
`),t.cause&&(this.cause=t.cause),this.details=r,this.docsPath=s,this.metaMessages=t.metaMessages,this.shortMessage=n}walk(n){return Se(this,z,"m",_e).call(this,this,n)}};z=new WeakSet,_e=function e(n,t){return t!=null&&t(n)?n:n.cause?Se(this,z,"m",e).call(this,n.cause,t):n};class V extends E{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}}class pt extends E{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}}class yt extends E{constructor(){super("Connector not connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}}class gt extends E{constructor({address:n,connector:t}){super(`Account "${n}" not found for connector "${t.name}".`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}}class M extends E{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}}const mt=/(rabby|trustwallet)/,wt={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider(e){return e!=null&&e.coinbaseWalletExtension?e.coinbaseWalletExtension:T(e,"isCoinbaseWallet")}},metaMask:{id:"metaMask",name:"MetaMask",provider(e){return T(e,n=>{if(!n.isMetaMask||n.isBraveWallet&&!n._events&&!n._state)return!1;const t=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPortal","isRabby","isTokenPocket","isTokenary","isZerion"];for(const r of t)if(n[r])return!1;return!0})}},phantom:{id:"phantom",name:"Phantom",provider(e){var n,t;return(n=e==null?void 0:e.phantom)!=null&&n.ethereum?(t=e.phantom)==null?void 0:t.ethereum:T(e,"isPhantom")}}};ue.type="injected";function ue(e={}){const{shimDisconnect:n=!0,unstable_shimAsyncInject:t}=e;function r(){const u=e.target;if(typeof u=="function"){const c=u();if(c)return c}return typeof u=="object"?u:typeof u=="string"?{...wt[u]??{id:u,name:`${u[0].toUpperCase()}${u.slice(1)}`,provider:`is${u[0].toUpperCase()}${u.slice(1)}`}}:{id:"injected",name:"Injected",provider(c){return c==null?void 0:c.ethereum}}}let s,o,i,l;return u=>({get icon(){return r().icon},get id(){return r().id},get name(){return r().name},get supportsSimulation(){return mt.test(this.id.toLowerCase())},type:ue.type,async setup(){const c=await this.getProvider();c&&e.target&&(i||(i=this.onConnect.bind(this),c.on("connect",i)),s||(s=this.onAccountsChanged.bind(this),c.on("accountsChanged",s)))},async connect({chainId:c,isReconnecting:f}={}){var g,w,b,m,C,_;const d=await this.getProvider();if(!d)throw new M;let a=[];if(f)a=await this.getAccounts().catch(()=>[]);else if(n)try{a=(m=(b=(w=(g=(await d.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}))[0])==null?void 0:g.caveats)==null?void 0:w[0])==null?void 0:b.value)==null?void 0:m.map(h=>k(h))}catch(I){const h=I;if(h.code===q.code)throw new q(h);if(h.code===ee.code)throw h}try{!(a!=null&&a.length)&&!f&&(a=(await d.request({method:"eth_requestAccounts"})).map(p=>k(p))),i&&(d.removeListener("connect",i),i=void 0),s||(s=this.onAccountsChanged.bind(this),d.on("accountsChanged",s)),o||(o=this.onChainChanged.bind(this),d.on("chainChanged",o)),l||(l=this.onDisconnect.bind(this),d.on("disconnect",l));let I=await this.getChainId();if(c&&I!==c){const h=await this.switchChain({chainId:c}).catch(p=>{if(p.code===q.code)throw p;return{id:I}});I=(h==null?void 0:h.id)??I}return n&&await((C=u.storage)==null?void 0:C.removeItem(`${this.id}.disconnected`)),e.target||await((_=u.storage)==null?void 0:_.setItem("injected.connected",!0)),{accounts:a,chainId:I}}catch(I){const h=I;throw h.code===q.code?new q(h):h.code===ee.code?new ee(h):h}},async disconnect(){var f,d;const c=await this.getProvider();if(!c)throw new M;o&&(c.removeListener("chainChanged",o),o=void 0),l&&(c.removeListener("disconnect",l),l=void 0),i||(i=this.onConnect.bind(this),c.on("connect",i));try{await c.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}n&&await((f=u.storage)==null?void 0:f.setItem(`${this.id}.disconnected`,!0)),e.target||await((d=u.storage)==null?void 0:d.removeItem("injected.connected"))},async getAccounts(){const c=await this.getProvider();if(!c)throw new M;return(await c.request({method:"eth_accounts"})).map(d=>k(d))},async getChainId(){const c=await this.getProvider();if(!c)throw new M;const f=await c.request({method:"eth_chainId"});return Number(f)},async getProvider(){if(typeof window>"u")return;let c;const f=r();return typeof f.provider=="function"?c=f.provider(window):typeof f.provider=="string"?c=T(window,f.provider):c=f.provider,c&&!c.removeListener&&("off"in c&&typeof c.off=="function"?c.removeListener=c.off:c.removeListener=()=>{}),c},async isAuthorized(){var c,f;try{if(n&&await((c=u.storage)==null?void 0:c.getItem(`${this.id}.disconnected`))||!e.target&&!await((f=u.storage)==null?void 0:f.getItem("injected.connected")))return!1;if(!await this.getProvider()){if(t!==void 0&&t!==!1){const w=async()=>(typeof window<"u"&&window.removeEventListener("ethereum#initialized",w),!!await this.getProvider()),b=typeof t=="number"?t:1e3;if(await Promise.race([...typeof window<"u"?[new Promise(C=>window.addEventListener("ethereum#initialized",()=>C(w()),{once:!0}))]:[],new Promise(C=>setTimeout(()=>C(w()),b))]))return!0}throw new M}return!!(await Ee(()=>De(()=>this.getAccounts(),{timeout:100}))).length}catch{return!1}},async switchChain({addEthereumChainParameter:c,chainId:f}){var g,w,b,m;const d=await this.getProvider();if(!d)throw new M;const a=u.chains.find(C=>C.id===f);if(!a)throw new re(new V);try{return await Promise.all([d.request({method:"wallet_switchEthereumChain",params:[{chainId:F(f)}]}).then(async()=>{await this.getChainId()===f&&u.emitter.emit("change",{chainId:f})}),new Promise(C=>u.emitter.once("change",({chainId:_})=>{_===f&&C()}))]),a}catch(C){const _=C;if(_.code===4902||((w=(g=_==null?void 0:_.data)==null?void 0:g.originalError)==null?void 0:w.code)===4902)try{const{default:I,...h}=a.blockExplorers??{};let p;c!=null&&c.blockExplorerUrls?p=c.blockExplorerUrls:I&&(p=[I.url,...Object.values(h).map(U=>U.url)]);let y;(b=c==null?void 0:c.rpcUrls)!=null&&b.length?y=c.rpcUrls:y=[((m=a.rpcUrls.default)==null?void 0:m.http[0])??""];const v={blockExplorerUrls:p,chainId:F(f),chainName:(c==null?void 0:c.chainName)??a.name,iconUrls:c==null?void 0:c.iconUrls,nativeCurrency:(c==null?void 0:c.nativeCurrency)??a.nativeCurrency,rpcUrls:y};if(await d.request({method:"wallet_addEthereumChain",params:[v]}),await this.getChainId()!==f)throw new q(new Error("User rejected switch after adding network."));return a}catch(I){throw new q(I)}throw _.code===q.code?new q(_):new re(_)}},async onAccountsChanged(c){var f;if(c.length===0)this.onDisconnect();else if(u.emitter.listenerCount("connect")){const d=(await this.getChainId()).toString();this.onConnect({chainId:d}),n&&await((f=u.storage)==null?void 0:f.removeItem(`${this.id}.disconnected`))}else u.emitter.emit("change",{accounts:c.map(d=>k(d))})},onChainChanged(c){const f=Number(c);u.emitter.emit("change",{chainId:f})},async onConnect(c){const f=await this.getAccounts();if(f.length===0)return;const d=Number(c.chainId);u.emitter.emit("connect",{accounts:f,chainId:d});const a=await this.getProvider();a&&(i&&(a.removeListener("connect",i),i=void 0),s||(s=this.onAccountsChanged.bind(this),a.on("accountsChanged",s)),o||(o=this.onChainChanged.bind(this),a.on("chainChanged",o)),l||(l=this.onDisconnect.bind(this),a.on("disconnect",l)))},async onDisconnect(c){const f=await this.getProvider();c&&c.code===1013&&f&&(await this.getAccounts()).length||(u.emitter.emit("disconnect"),f&&(o&&(f.removeListener("chainChanged",o),o=void 0),l&&(f.removeListener("disconnect",l),l=void 0),i||(i=this.onConnect.bind(this),f.on("connect",i))))}})}function T(e,n){function t(s){return typeof n=="function"?n(s):typeof n=="string"?s[n]:!0}const r=e.ethereum;if(r!=null&&r.providers)return r.providers.find(s=>t(s));if(r&&t(r))return r}const oe=256;let x=oe,W;function bt(e=11){if(!W||x+e>oe*2){W="",x=0;for(let n=0;n<oe;n++)W+=(256+Math.random()*256|0).toString(16).substring(1)}return W.substring(x,x+++e)}function yn(e){const{multiInjectedProviderDiscovery:n=!0,storage:t=ft({storage:typeof window<"u"&&window.localStorage?window.localStorage:Ie}),syncConnectedChain:r=!0,ssr:s,...o}=e,i=typeof window<"u"&&n?Je():void 0,l=Y(()=>o.chains),u=Y(()=>[...o.connectors??[],...s?[]:(i==null?void 0:i.getProviders().map(f))??[]].map(c));function c(h){var v;const p=at(bt()),y={...h({emitter:p,chains:l.getState(),storage:t}),emitter:p,uid:p.uid};return p.on("connect",_),(v=y.setup)==null||v.call(y),y}function f(h){const{info:p}=h,y=h.provider;return ue({target:{...p,id:p.rdns,provider:y}})}const d=new Map;function a(h={}){const p=h.chainId??m.getState().chainId,y=l.getState().find(S=>S.id===p);if(h.chainId&&!y)throw new V;{const S=d.get(m.getState().chainId);if(S&&!y)return S;if(!y)throw new V}{const S=d.get(p);if(S)return S}let v;if(o.client)v=o.client({chain:y});else{const S=y.id,U=l.getState().map(O=>O.id),P={},X=Object.entries(o);for(const[O,$]of X)if(!(O==="chains"||O==="client"||O==="connectors"||O==="transports"))if(typeof $=="object")if(S in $)P[O]=$[S];else{if(U.some(fe=>fe in $))continue;P[O]=$}else P[O]=$;v=we({...P,chain:y,batch:P.batch??{multicall:!0},transport:O=>o.transports[S]({...O,connectors:u})})}return d.set(p,v),v}function g(){return{chainId:l.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let w;const b="0.0.0-canary-";B.startsWith(b)?w=parseInt(B.replace(b,"")):w=parseInt(B.split(".")[0]??"0");const m=Y(Ue(t?Re(g,{migrate(h,p){if(p===w)return h;const y=g(),v=h&&typeof h=="object"&&"chainId"in h&&typeof h.chainId=="number"?h.chainId:y.chainId;return{...y,chainId:v}},name:"store",partialize(h){return{connections:{__type:"Map",value:Array.from(h.connections.entries()).map(([p,y])=>{const{id:v,name:S,type:U,uid:P}=y.connector;return[p,{...y,connector:{id:v,name:S,type:U,uid:P}}]})},chainId:h.chainId,current:h.current}},skipHydration:s,storage:t,version:w}):g));r&&m.subscribe(({connections:h,current:p})=>{var y;return p?(y=h.get(p))==null?void 0:y.chainId:void 0},h=>{if(l.getState().some(y=>y.id===h))return m.setState(y=>({...y,chainId:h??y.chainId}))}),i==null||i.subscribe(h=>{const p=new Map;for(const v of u.getState())p.set(v.id,!0);const y=[];for(const v of h){const S=c(f(v));p.has(S.id)||y.push(S)}t&&!m.persist.hasHydrated()||u.setState(v=>[...v,...y],!0)});function C(h){m.setState(p=>{const y=p.connections.get(h.uid);return y?{...p,connections:new Map(p.connections).set(h.uid,{accounts:h.accounts??y.accounts,chainId:h.chainId??y.chainId,connector:y.connector})}:p})}function _(h){m.getState().status==="connecting"||m.getState().status==="reconnecting"||m.setState(p=>{const y=u.getState().find(v=>v.uid===h.uid);return y?(y.emitter.listenerCount("connect")&&y.emitter.off("connect",C),y.emitter.listenerCount("change")||y.emitter.on("change",C),y.emitter.listenerCount("disconnect")||y.emitter.on("disconnect",I),{...p,connections:new Map(p.connections).set(h.uid,{accounts:h.accounts,chainId:h.chainId,connector:y}),current:h.uid,status:"connected"}):p})}function I(h){m.setState(p=>{const y=p.connections.get(h.uid);if(y){const S=y.connector;S.emitter.listenerCount("change")&&y.connector.emitter.off("change",C),S.emitter.listenerCount("disconnect")&&y.connector.emitter.off("disconnect",I),S.emitter.listenerCount("connect")||y.connector.emitter.on("connect",_)}if(p.connections.delete(h.uid),p.connections.size===0)return{...p,connections:new Map,current:null,status:"disconnected"};const v=p.connections.values().next().value;return{...p,connections:new Map(p.connections),current:v.connector.uid}})}return{get chains(){return l.getState()},get connectors(){return u.getState()},storage:t,getClient:a,get state(){return m.getState()},setState(h){let p;typeof h=="function"?p=h(m.getState()):p=h;const y=g();typeof p!="object"&&(p=y),Object.keys(y).some(S=>!(S in p))&&(p=y),m.setState(p,!0)},subscribe(h,p,y){return m.subscribe(h,p,y?{...y,fireImmediately:y.emitImmediately}:void 0)},_internal:{mipd:i,store:m,ssr:!!s,syncConnectedChain:r,transports:o.transports,chains:{setState(h){const p=typeof h=="function"?h(l.getState()):h;if(p.length!==0)return l.setState(p,!0)},subscribe(h){return l.subscribe(h)}},connectors:{providerDetailToConnector:f,setup:c,setState(h){return u.setState(typeof h=="function"?h(u.getState()):h,!0)},subscribe(h){return u.subscribe(h)}},events:{change:C,connect:_,disconnect:I}}}}function K(e,n,t){const r=e[n.name];if(typeof r=="function")return r;const s=e[t];return typeof s=="function"?s:o=>n(e,o)}async function Ct(e,n){var r;let t;if(typeof n.connector=="function"?t=e._internal.connectors.setup(n.connector):t=n.connector,t.uid===e.state.current)throw new pt;try{e.setState(i=>({...i,status:"connecting"})),t.emitter.emit("message",{type:"connecting"});const s=await t.connect({chainId:n.chainId}),o=s.accounts;return t.emitter.off("connect",e._internal.events.connect),t.emitter.on("change",e._internal.events.change),t.emitter.on("disconnect",e._internal.events.disconnect),await((r=e.storage)==null?void 0:r.setItem("recentConnectorId",t.id)),e.setState(i=>({...i,connections:new Map(i.connections).set(t.uid,{accounts:o,chainId:s.chainId,connector:t}),current:t.uid,status:"connected"})),{accounts:o,chainId:s.chainId}}catch(s){throw e.setState(o=>({...o,status:o.current?"connected":"disconnected"})),s}}async function vt(e,n={}){var s,o;let t;if(n.connector)t=n.connector;else{const{connections:i,current:l}=e.state,u=i.get(l);t=u==null?void 0:u.connector}const r=e.state.connections;t&&(await t.disconnect(),t.emitter.off("change",e._internal.events.change),t.emitter.off("disconnect",e._internal.events.disconnect),t.emitter.on("connect",e._internal.events.connect),r.delete(t.uid)),e.setState(i=>{if(r.size===0)return{...i,connections:new Map,current:null,status:"disconnected"};const l=r.values().next().value;return{...i,connections:new Map(r),current:l.connector.uid}});{const i=e.state.current;if(!i)return;const l=(s=e.state.connections.get(i))==null?void 0:s.connector;if(!l)return;await((o=e.storage)==null?void 0:o.setItem("recentConnectorId",l.id))}}async function le(e,n={}){let t;if(n.connector){const{connector:u}=n,[c,f]=await Promise.all([u.getAccounts(),u.getChainId()]);t={accounts:c,chainId:f,connector:u}}else t=e.state.connections.get(e.state.current);if(!t)throw new yt;const r=n.chainId??t.chainId,s=t.connector;if(s.getClient)return s.getClient({chainId:r});const o=Ke(n.account??t.accounts[0]);o.address=k(o.address);const i=e.chains.find(u=>u.id===r),l=await t.connector.getProvider({chainId:r});if(n.account&&!t.accounts.some(u=>u.toLowerCase()===o.address.toLowerCase()))throw new gt({address:o.address,connector:s});return we({account:o,chain:i,name:"Connector Client",transport:u=>xe(l)({...u,retryCount:0})})}function Oe(e){return typeof e=="number"?e:e==="wei"?0:Math.abs(We[e])}function de(e){const n=e.state.current,t=e.state.connections.get(n),r=t==null?void 0:t.accounts,s=r==null?void 0:r[0],o=e.chains.find(l=>l.id===(t==null?void 0:t.chainId)),i=e.state.status;switch(i){case"connected":return{address:s,addresses:r,chain:o,chainId:t==null?void 0:t.chainId,connector:t==null?void 0:t.connector,isConnected:!0,isConnecting:!1,isDisconnected:!1,isReconnecting:!1,status:i};case"reconnecting":return{address:s,addresses:r,chain:o,chainId:t==null?void 0:t.chainId,connector:t==null?void 0:t.connector,isConnected:!!s,isConnecting:!1,isDisconnected:!1,isReconnecting:!0,status:i};case"connecting":return{address:s,addresses:r,chain:o,chainId:t==null?void 0:t.chainId,connector:t==null?void 0:t.connector,isConnected:!1,isConnecting:!0,isDisconnected:!1,isReconnecting:!1,status:i};case"disconnected":return{address:void 0,addresses:void 0,chain:void 0,chainId:void 0,connector:void 0,isConnected:!1,isConnecting:!1,isDisconnected:!0,isReconnecting:!1,status:i}}}async function It(e,n){const{allowFailure:t=!0,chainId:r,contracts:s,...o}=n,i=e.getClient({chainId:r});return K(i,Le,"multicall")({allowFailure:t,contracts:s,...o})}function qe(e,n){const{chainId:t,...r}=n,s=e.getClient({chainId:t});return K(s,Be,"readContract")(r)}async function St(e,n){const{allowFailure:t=!0,blockNumber:r,blockTag:s,...o}=n,i=n.contracts;try{const l=i.reduce((d,a,g)=>{const w=a.chainId??e.state.chainId;return{...d,[w]:[...d[w]||[],{contract:a,index:g}]}},{}),u=()=>Object.entries(l).map(([d,a])=>It(e,{...o,allowFailure:t,blockNumber:r,blockTag:s,chainId:parseInt(d),contracts:a.map(({contract:g})=>g)})),c=(await Promise.all(u())).flat(),f=Object.values(l).flatMap(d=>d.map(({index:a})=>a));return c.reduce((d,a,g)=>(d&&(d[f[g]]=a),d),[])}catch(l){if(l instanceof be)throw l;const u=()=>i.map(c=>qe(e,{...c,blockNumber:r,blockTag:s}));return t?(await Promise.allSettled(u())).map(c=>c.status==="fulfilled"?{result:c.value,status:"success"}:{error:c.reason,result:void 0,status:"failure"}):await Promise.all(u())}}async function _t(e,n){const{address:t,blockNumber:r,blockTag:s,chainId:o,token:i,unit:l="ether"}=n;if(i)try{return ge(e,{balanceAddress:t,chainId:o,symbolType:"string",tokenAddress:i})}catch(a){if(a instanceof be){const g=await ge(e,{balanceAddress:t,chainId:o,symbolType:"bytes32",tokenAddress:i}),w=Te(Fe(g.symbol,{dir:"right"}));return{...g,symbol:w}}throw a}const u=e.getClient({chainId:o}),f=await K(u,Qe,"getBalance")(r?{address:t,blockNumber:r}:{address:t,blockTag:s}),d=e.chains.find(a=>a.id===o)??u.chain;return{decimals:d.nativeCurrency.decimals,formatted:Ce(f,Oe(l)),symbol:d.nativeCurrency.symbol,value:f}}async function ge(e,n){const{balanceAddress:t,chainId:r,symbolType:s,tokenAddress:o,unit:i}=n,l={abi:[{type:"function",name:"balanceOf",stateMutability:"view",inputs:[{type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:s}]}],address:o},[u,c,f]=await St(e,{allowFailure:!1,contracts:[{...l,functionName:"balanceOf",args:[t],chainId:r},{...l,functionName:"decimals",chainId:r},{...l,functionName:"symbol",chainId:r}]}),d=Ce(u??"0",Oe(i??c));return{decimals:c,formatted:d,symbol:f,value:u}}function Ot(e){return e.state.chainId}function N(e,n){if(e===n)return!0;if(e&&n&&typeof e=="object"&&typeof n=="object"){if(e.constructor!==n.constructor)return!1;let t,r;if(Array.isArray(e)&&Array.isArray(n)){if(t=e.length,t!==n.length)return!1;for(r=t;r--!==0;)if(!N(e[r],n[r]))return!1;return!0}if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===n.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===n.toString();const s=Object.keys(e);if(t=s.length,t!==Object.keys(n).length)return!1;for(r=t;r--!==0;)if(!Object.prototype.hasOwnProperty.call(n,s[r]))return!1;for(r=t;r--!==0;){const o=s[r];if(o&&!N(e[o],n[o]))return!1}return!0}return e!==e&&n!==n}let L=[];function je(e){const n=[...e.state.connections.values()];return e.state.status==="reconnecting"||N(L,n)?L:(L=n,n)}let te=[];function qt(e){const n=e.connectors;return N(te,n)?te:(te=n,n)}let ne=!1;async function jt(e,n={}){var c,f;if(ne)return[];ne=!0,e.setState(d=>({...d,status:d.current?"reconnecting":"connecting"}));const t=[];if((c=n.connectors)!=null&&c.length)for(const d of n.connectors){let a;typeof d=="function"?a=e._internal.connectors.setup(d):a=d,t.push(a)}else t.push(...e.connectors);let r;try{r=await((f=e.storage)==null?void 0:f.getItem("recentConnectorId"))}catch{}const s={};for(const[,d]of e.state.connections)s[d.connector.id]=1;r&&(s[r]=0);const o=Object.keys(s).length>0?[...t].sort((d,a)=>(s[d.id]??10)-(s[a.id]??10)):t;let i=!1;const l=[],u=[];for(const d of o){const a=await d.getProvider().catch(()=>{});if(!a||u.some(b=>b===a)||!await d.isAuthorized())continue;const w=await d.connect({isReconnecting:!0}).catch(()=>null);w&&(d.emitter.off("connect",e._internal.events.connect),d.emitter.on("change",e._internal.events.change),d.emitter.on("disconnect",e._internal.events.disconnect),e.setState(b=>{const m=new Map(i?b.connections:new Map).set(d.uid,{accounts:w.accounts,chainId:w.chainId,connector:d});return{...b,current:i?b.current:d.uid,connections:m}}),l.push({accounts:w.accounts,chainId:w.chainId,connector:d}),u.push(a),i=!0)}return(e.state.status==="reconnecting"||e.state.status==="connecting")&&(i?e.setState(d=>({...d,status:"connected"})):e.setState(d=>({...d,connections:new Map,current:null,status:"disconnected"}))),ne=!1,l}async function Ae(e,n){const{abi:t,chainId:r,connector:s,...o}=n;let i;n.account?i=n.account:i=(await le(e,{chainId:r,connector:s})).account;const l=e.getClient({chainId:r}),u=K(l,ze,"simulateContract"),{result:c,request:f}=await u({...o,abi:t,account:i});return{chainId:l.chain.id,result:c,request:{__mode:"prepared",...f,chainId:r}}}function At(e,n){const{onChange:t}=n;return e.subscribe(()=>de(e),t,{equalityFn(r,s){const{connector:o,...i}=r,{connector:l,...u}=s;return N(i,u)&&(o==null?void 0:o.id)===(l==null?void 0:l.id)&&(o==null?void 0:o.uid)===(l==null?void 0:l.uid)}})}function Pt(e,n){const{onChange:t}=n;return e.subscribe(r=>r.chainId,t)}function Mt(e,n){const{onChange:t}=n;return e.subscribe(()=>je(e),t,{equalityFn:N})}function kt(e,n){const{onChange:t}=n;return e._internal.connectors.subscribe((r,s)=>{t(Object.values(r),s)})}async function $t(e,n){const{account:t,chainId:r,connector:s,__mode:o,...i}=n;let l;typeof t=="object"&&t.type==="local"?l=e.getClient({chainId:r}):l=await le(e,{account:t,chainId:r,connector:s});const{connector:u}=de(e);let c;if(o==="prepared"||u!=null&&u.supportsSimulation)c=i;else{const{request:a}=await Ae(e,{...i,account:t,chainId:r});c=a}return await K(l,Ve,"writeContract")({...c,...t?{account:t}:{},chain:r?{id:r}:null})}function Nt(e,n){const{initialState:t,reconnectOnMount:r}=n;return t&&!e._internal.store.persist.hasHydrated()&&e.setState({...t,connections:r?t.connections:new Map,status:r?"reconnecting":"disconnected"}),{async onMount(){var s;if(e._internal.ssr){await e._internal.store.persist.rehydrate();const o=(s=e._internal.mipd)==null?void 0:s.getProviders().map(e._internal.connectors.providerDetailToConnector).map(e._internal.connectors.setup);e._internal.connectors.setState(i=>[...i,...o??[]])}r?jt(e):e.storage&&e.setState(o=>({...o,connections:new Map}))}}}const Pe=Symbol(),gn={install(e,n){const{config:t,reconnectOnMount:r=!0}=n;e.provide(Pe,t);const{onMount:s}=Nt(t,{...n,reconnectOnMount:r});s()}},Ut="0.0.10",Rt=()=>`@wagmi/vue@${Ut}`;class Me extends E{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiError"})}get docsBaseUrl(){return"https://wagmi.sh/vue"}get version(){return Rt()}}class Et extends Me{constructor(){super("No `config` found in Vue context, use `WagmiPlugin` to properly initialize the library.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiPluginNotFoundError"})}}class Dt extends Me{constructor(){super("Wagmi composables can only be used inside `setup()` function or functions that support injection context.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiInjectionContextError"})}}function Kt(e,n){Object.keys(e).forEach(t=>{e[t]=n[t]})}function A(e={}){const n=Q(e);if(n.config)return n.config;if(!Ge())throw new Dt;const t=Ze(Pe);if(!t)throw new Et;return t}function xt(e={}){const n=A(e),t=Xe(de(n)),r=At(n,{onChange(s){Kt(t,s)}});return D(()=>r()),Ye(ie(t))}function ce(e,n){if(n){const t=n(e);if(t===void 0&&ve(e)||t!==void 0)return t}if(Array.isArray(e))return e.map(t=>ce(t,n));if(typeof e=="object"&&Wt(e)){const t=Object.entries(e).map(([r,s])=>[r,ce(s,n)]);return Object.fromEntries(t)}return e}function R(e){return ce(e,n=>{if(ve(n))return R(Q(n))})}function Wt(e){if(Object.prototype.toString.call(e)!=="[object Object]")return!1;const n=Object.getPrototypeOf(e);return n===null||n===Object.prototype}function Lt(e,n){return N(e,n)?e:tt(e,n)}function Bt(e){return JSON.stringify(e,(n,t)=>Tt(t)?Object.keys(t).sort().reduce((r,s)=>(r[s]=t[s],r),{}):typeof t=="bigint"?t.toString():t)}function Tt(e){if(!me(e))return!1;const n=e.constructor;if(typeof n>"u")return!0;const t=n.prototype;return!(!me(t)||!t.hasOwnProperty("isPrototypeOf"))}function me(e){return Object.prototype.toString.call(e)==="[object Object]"}function J(e){const{_defaulted:n,behavior:t,gcTime:r,initialData:s,initialDataUpdatedAt:o,maxPages:i,meta:l,networkMode:u,queryFn:c,queryHash:f,queryKey:d,queryKeyHashFn:a,retry:g,retryDelay:w,structuralSharing:b,getPreviousPageParam:m,getNextPageParam:C,initialPageParam:_,_optimisticResults:I,enabled:h,notifyOnChangeProps:p,placeholderData:y,refetchInterval:v,refetchIntervalInBackground:S,refetchOnMount:U,refetchOnReconnect:P,refetchOnWindowFocus:X,retryOnMount:O,select:$,staleTime:$e,suspense:fe,throwOnError:sn,config:on,connector:cn,query:an,...Ne}=e;return Ne}function Ft(e){return{mutationFn(n){return Ct(e,n)},mutationKey:["connect"]}}function Qt(e){return{mutationFn(n){return vt(e,n)},mutationKey:["disconnect"]}}function zt(e,n={}){return{async queryFn({queryKey:t}){const{address:r,scopeKey:s,...o}=t[1];if(!r)throw new Error("address is required");return await _t(e,{...o,address:r})??null},queryKey:Vt(n)}}function Vt(e={}){return["balance",J(e)]}function Ht(e,n={}){return{gcTime:0,async queryFn({queryKey:t}){const{connector:r}=n,{connectorUid:s,scopeKey:o,...i}=t[1];return le(e,{...i,connector:r})},queryKey:Jt(n)}}function Jt(e={}){const{connector:n,...t}=e;return["connectorClient",{...J(t),connectorUid:n==null?void 0:n.uid}]}function Gt(e,n={}){return{async queryFn({queryKey:t}){const r=n.abi;if(!r)throw new Error("abi is required");const{address:s,functionName:o,scopeKey:i,...l}=t[1];if(!s)throw new Error("address is required");if(!o)throw new Error("functionName is required");const u=l.args;return qe(e,{abi:r,address:s,functionName:o,args:u,...l})},queryKey:Zt(n)}}function Zt(e={}){const{abi:n,...t}=e;return["readContract",J(t)]}function Xt(e,n={}){return{async queryFn({queryKey:t}){const{abi:r,connector:s}=n;if(!r)throw new Error("abi is required");const{scopeKey:o,...i}=t[1],{address:l,functionName:u}=i;if(!l)throw new Error("address is required");if(!u)throw new Error("functionName is required");return Ae(e,{abi:r,connector:s,...i})},queryKey:Yt(n)}}function Yt(e={}){const{abi:n,connector:t,...r}=e;return["simulateContract",J(r)]}function en(e){return{mutationFn(n){return $t(e,n)},mutationKey:["writeContract"]}}function G(e){const n=j(()=>({...Q(e),queryKeyHashFn:Bt})),t=nt(n);return t.queryKey=Q(n).queryKey,t}function Z(e={}){const n=A(e),t=H(Ot(n)),r=Pt(n,{onChange(s){t.value=s}});return D(()=>r()),ie(t)}function mn(e={}){const n=j(()=>R(e)),t=A(n),r=Z({config:t}),s=j(()=>{const{address:o,chainId:i=r.value,query:l={}}=n.value,u=zt(t,{...n.value,chainId:i}),c=!!(o&&(l.enabled??!0));return{...l,...u,enabled:c}});return G(s)}function tn(e={}){const n=j(()=>R(e)),t=A(n),r=rt(),{address:s,connector:o,status:i}=xt({config:t}),l=Z({config:t}),u=j(()=>{const{chainId:f=l.value,connector:d=o.value,query:a={}}=n.value,{queryKey:g,...w}=Ht(t,{...R(n),chainId:f,connector:d}),b=!!(i.value!=="disconnected"&&(a.enabled??!0));return{...a,...w,queryKey:g,enabled:b,staleTime:1/0}}),c=H(s);return et(()=>{const f=c.value;!s&&f?(r.removeQueries({queryKey:u.value.queryKey}),c.value=void 0):s.value!==f&&(r.invalidateQueries({queryKey:u.value.queryKey}),c.value=s.value)}),G(u)}function nn(e={}){const n=A(e),t=H(qt(n)),r=kt(n,{onChange(s){t.value=s}});return D(()=>r()),t}function wn(e={}){const{mutation:n}=e,t=A(e),r=Ft(t),{mutate:s,mutateAsync:o,...i}=ae({...n,...r}),l=t.subscribe(({status:u})=>u,(u,c)=>{c==="connected"&&u==="disconnected"&&i.reset()});return D(()=>l()),{...i,connect:s,connectAsync:o,connectors:nn({config:t}).value}}function rn(e={}){const n=A(e),t=H(je(n)),r=Mt(n,{onChange(s){t.value=s}});return D(()=>r()),ie(t)}function bn(e={}){const{mutation:n}=e,t=A(e),r=rn({config:t}),s=Qt(t),{mutate:o,mutateAsync:i,...l}=ae({...n,...s});return{...l,connectors:j(()=>r.value.map(u=>u.connector)),disconnect:o,disconnectAsync:i}}function Cn(e={}){const n=j(()=>R(e)),t=A(n),r=Z({config:t}),s=j(()=>{const{abi:o,address:i,chainId:l=r.value,functionName:u,query:c={}}=n.value,f=Gt(t,{...n.value,chainId:l}),d=!!(i&&o&&u&&(c.enabled??!0));return{...c,...f,enabled:d,structuralSharing:c.structuralSharing??Lt}});return G(s)}function vn(e={}){const n=j(()=>R(e)),t=A(n),{data:r}=tn(j(()=>({connector:n.value.connector,query:{enabled:n.value.account===void 0}}))),s=Z({config:t}),o=j(()=>{var w;const{abi:i,account:l=(w=r==null?void 0:r.value)==null?void 0:w.account,address:u,chainId:c=s.value,functionName:f,query:d={}}=n.value,a=Xt(t,{...n.value,account:l,chainId:c}),g=!!(i&&u&&f&&(d.enabled??!0));return{...d,...a,enabled:g}});return G(o)}function In(e={}){const{mutation:n}=e,t=A(e),r=en(t),{mutate:s,mutateAsync:o,...i}=ae({...n,...r});return{...i,writeContract:s,writeContractAsync:o}}ke.type="walletConnect";function ke(e){const n=e.isNewChainsStale??!0;let t,r;const s="eip155";let o,i,l,u,c,f;return d=>({id:"walletConnect",name:"WalletConnect",type:ke.type,async setup(){const a=await this.getProvider().catch(()=>null);a&&(l||(l=this.onConnect.bind(this),a.on("connect",l)),c||(c=this.onSessionDelete.bind(this),a.on("session_delete",c)))},async connect({chainId:a,...g}={}){var w,b;try{const m=await this.getProvider();if(!m)throw new M;u||(u=this.onDisplayUri,m.on("display_uri",u));let C=a;if(!C){const p=await((w=d.storage)==null?void 0:w.getItem("state"))??{};d.chains.some(v=>v.id===p.chainId)?C=p.chainId:C=(b=d.chains[0])==null?void 0:b.id}if(!C)throw new Error("No chains found on connector.");const _=await this.isChainsStale();if(m.session&&_&&await m.disconnect(),!m.session||_){const p=d.chains.filter(y=>y.id!==C).map(y=>y.id);await m.connect({optionalChains:[C,...p],..."pairingTopic"in g?{pairingTopic:g.pairingTopic}:{}}),this.setRequestedChainsIds(d.chains.map(y=>y.id))}const I=(await m.enable()).map(p=>k(p)),h=await this.getChainId();return u&&(m.removeListener("display_uri",u),u=void 0),l&&(m.removeListener("connect",l),l=void 0),o||(o=this.onAccountsChanged.bind(this),m.on("accountsChanged",o)),i||(i=this.onChainChanged.bind(this),m.on("chainChanged",i)),f||(f=this.onDisconnect.bind(this),m.on("disconnect",f)),c||(c=this.onSessionDelete.bind(this),m.on("session_delete",c)),{accounts:I,chainId:h}}catch(m){throw/(user rejected|connection request reset)/i.test(m==null?void 0:m.message)?new q(m):m}},async disconnect(){const a=await this.getProvider();try{await(a==null?void 0:a.disconnect())}catch(g){if(!/No matching key/i.test(g.message))throw g}finally{i&&(a==null||a.removeListener("chainChanged",i),i=void 0),f&&(a==null||a.removeListener("disconnect",f),f=void 0),l||(l=this.onConnect.bind(this),a==null||a.on("connect",l)),o&&(a==null||a.removeListener("accountsChanged",o),o=void 0),c&&(a==null||a.removeListener("session_delete",c),c=void 0),this.setRequestedChainsIds([])}},async getAccounts(){return(await this.getProvider()).accounts.map(g=>k(g))},async getProvider({chainId:a}={}){var w;async function g(){const b=d.chains.map(C=>C.id);if(!b.length)return;const{EthereumProvider:m}=await ct(()=>import("./@walletconnect-JjN6c9yP.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37]));return await m.init({...e,disableProviderPing:!0,optionalChains:b,projectId:e.projectId,rpcMap:Object.fromEntries(d.chains.map(C=>[C.id,C.rpcUrls.default.http[0]])),showQrModal:e.showQrModal??!0})}return t||(r||(r=g()),t=await r,t==null||t.events.setMaxListeners(1/0)),a&&await((w=this.switchChain)==null?void 0:w.call(this,{chainId:a})),t},async getChainId(){return(await this.getProvider()).chainId},async isAuthorized(){try{const[a,g]=await Promise.all([this.getAccounts(),this.getProvider()]);return a.length?await this.isChainsStale()&&g.session?(await g.disconnect().catch(()=>{}),!1):!0:!1}catch{return!1}},async switchChain({addEthereumChainParameter:a,chainId:g}){var m,C,_;const w=await this.getProvider();if(!w)throw new M;const b=d.chains.find(I=>I.id===g);if(!b)throw new re(new V);try{await Promise.all([new Promise(h=>{const p=({chainId:y})=>{y===g&&(d.emitter.off("change",p),h())};d.emitter.on("change",p)}),w.request({method:"wallet_switchEthereumChain",params:[{chainId:F(g)}]})]);const I=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...I,g]),b}catch(I){const h=I;if(/(user rejected)/i.test(h.message))throw new q(h);try{let p;a!=null&&a.blockExplorerUrls?p=a.blockExplorerUrls:p=(m=b.blockExplorers)!=null&&m.default.url?[(C=b.blockExplorers)==null?void 0:C.default.url]:[];let y;(_=a==null?void 0:a.rpcUrls)!=null&&_.length?y=a.rpcUrls:y=[...b.rpcUrls.default.http];const v={blockExplorerUrls:p,chainId:F(g),chainName:(a==null?void 0:a.chainName)??b.name,iconUrls:a==null?void 0:a.iconUrls,nativeCurrency:(a==null?void 0:a.nativeCurrency)??b.nativeCurrency,rpcUrls:y};await w.request({method:"wallet_addEthereumChain",params:[v]});const S=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...S,g]),b}catch(p){throw new q(p)}}},onAccountsChanged(a){a.length===0?this.onDisconnect():d.emitter.emit("change",{accounts:a.map(g=>k(g))})},onChainChanged(a){const g=Number(a);d.emitter.emit("change",{chainId:g})},async onConnect(a){const g=Number(a.chainId),w=await this.getAccounts();d.emitter.emit("connect",{accounts:w,chainId:g})},async onDisconnect(a){this.setRequestedChainsIds([]),d.emitter.emit("disconnect");const g=await this.getProvider();o&&(g.removeListener("accountsChanged",o),o=void 0),i&&(g.removeListener("chainChanged",i),i=void 0),f&&(g.removeListener("disconnect",f),f=void 0),c&&(g.removeListener("session_delete",c),c=void 0),l||(l=this.onConnect.bind(this),g.on("connect",l))},onDisplayUri(a){d.emitter.emit("message",{type:"display_uri",data:a})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){var g,w,b;return t?((b=(w=(g=t.session)==null?void 0:g.namespaces[s])==null?void 0:w.accounts)==null?void 0:b.map(m=>parseInt(m.split(":")[1]||"")))??[]:[]},async getRequestedChainsIds(){var a;return await((a=d.storage)==null?void 0:a.getItem(this.requestedChainsStorageKey))??[]},async isChainsStale(){if(!n)return!1;const a=d.chains.map(b=>b.id),g=this.getNamespaceChainsIds();if(g.length&&!g.some(b=>a.includes(b)))return!1;const w=await this.getRequestedChainsIds();return!a.every(b=>w.includes(b))},async setRequestedChainsIds(a){var g;await((g=d.storage)==null?void 0:g.setItem(this.requestedChainsStorageKey,a))},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}})}export{gn as W,ct as _,xt as a,wn as b,bn as c,In as d,Cn as e,vn as f,yn as g,ue as i,mn as u,ke as w};
