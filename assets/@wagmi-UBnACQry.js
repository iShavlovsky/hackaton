import{c as L,s as fe,p as he}from"./zustand-BqGR2FB2.js";import{g as E,U as O,R as T,w as ge,a as pe,S as Q,n as X,c as me}from"./viem-BEj-Kv38.js";import{E as we}from"./eventemitter3-tQC854ZF.js";import{c as be}from"./mipd-CIcDX0W7.js";import{u as ye,h as ve,i as Ce,b as Ie,t as Se,d as te,o as B,r as ne,c as _e}from"./@vue-CdJJkxHS.js";import{u as re}from"./@tanstack-DPbx3v7X.js";class je{constructor(n){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new we})}on(n,t){this._emitter.on(n,t)}once(n,t){this._emitter.once(n,t)}off(n,t){this._emitter.off(n,t)}emit(n,...t){const c=t[0];this._emitter.emit(n,{uid:this.uid,...c})}listenerCount(n){return this._emitter.listenerCount(n)}}function Oe(e){return new je(e)}function Me(e,n){return JSON.parse(e,(t,c)=>{let r=c;return(r==null?void 0:r.__type)==="bigint"&&(r=BigInt(r.value)),(r==null?void 0:r.__type)==="Map"&&(r=new Map(r.value)),(n==null?void 0:n(t,r))??r})}function Y(e,n){return e.slice(0,n).join(".")||"."}function ee(e,n){const{length:t}=e;for(let c=0;c<t;++c)if(e[c]===n)return c+1;return 0}function Ae(e,n){const t=typeof e=="function",c=typeof n=="function",r=[],a=[];return function(f,u){if(typeof u=="object")if(r.length){const o=ee(r,this);o===0?r[r.length]=this:(r.splice(o),a.splice(o)),a[a.length]=f;const g=ee(r,u);if(g!==0)return c?n.call(this,f,u,Y(a,g)):`[ref=${Y(a,g)}]`}else r[0]=u,a[0]=f;return t?e.call(this,f,u):u}}function Pe(e,n,t,c){return JSON.stringify(e,Ae((r,a)=>{let i=a;return typeof i=="bigint"&&(i={__type:"bigint",value:a.toString()}),i instanceof Map&&(i={__type:"Map",value:Array.from(a.entries())}),(n==null?void 0:n(r,i))??i},c),t??void 0)}function $e(e){const{deserialize:n=Me,key:t="wagmi",serialize:c=Pe,storage:r=ce}=e;function a(i){return i instanceof Promise?i.then(f=>f).catch(()=>null):i}return{...r,key:t,async getItem(i,f){const u=r.getItem(`${t}.${i}`),o=await a(u);return o?n(o)??null:f??null},async setItem(i,f){const u=`${t}.${i}`;f===null?await a(r.removeItem(u)):await a(r.setItem(u,c(f)))},async removeItem(i){await a(r.removeItem(`${t}.${i}`))}}}const ce={getItem:()=>null,setItem:()=>{},removeItem:()=>{}};const U="2.10.4",We=()=>`@wagmi/core@${U}`;var oe=function(e,n,t,c){if(t==="a"&&!c)throw new TypeError("Private accessor was defined without a getter");if(typeof n=="function"?e!==n||!c:!n.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?c:t==="a"?c.call(e):c?c.value:n.get(e)},q,se;let N=class V extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return We()}constructor(n,t={}){var a;super(),q.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});const c=t.cause instanceof V?t.cause.details:(a=t.cause)!=null&&a.message?t.cause.message:t.details,r=t.cause instanceof V&&t.cause.docsPath||t.docsPath;this.message=[n||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...r?[`Docs: ${this.docsBaseUrl}${r}.html${t.docsSlug?`#${t.docsSlug}`:""}`]:[],...c?[`Details: ${c}`]:[],`Version: ${this.version}`].join(`
`),t.cause&&(this.cause=t.cause),this.details=c,this.docsPath=r,this.metaMessages=t.metaMessages,this.shortMessage=n}walk(n){return oe(this,q,"m",se).call(this,this,n)}};q=new WeakSet,se=function e(n,t){return t!=null&&t(n)?n:n.cause?oe(this,q,"m",e).call(this,n.cause,t):n};class H extends N{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}}class ke extends N{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}}class P extends N{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}}const Ee=/(rabby|trustwallet)/,De={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider(e){return e!=null&&e.coinbaseWalletExtension?e.coinbaseWalletExtension:z(e,"isCoinbaseWallet")}},metaMask:{id:"metaMask",name:"MetaMask",provider(e){return z(e,n=>{if(!n.isMetaMask||n.isBraveWallet&&!n._events&&!n._state)return!1;const t=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPortal","isRabby","isTokenPocket","isTokenary","isZerion"];for(const c of t)if(n[c])return!1;return!0})}},phantom:{id:"phantom",name:"Phantom",provider(e){var n,t;return(n=e==null?void 0:e.phantom)!=null&&n.ethereum?(t=e.phantom)==null?void 0:t.ethereum:z(e,"isPhantom")}}};J.type="injected";function J(e={}){const{shimDisconnect:n=!0,unstable_shimAsyncInject:t}=e;function c(){const u=e.target;if(typeof u=="function"){const o=u();if(o)return o}return typeof u=="object"?u:typeof u=="string"?{...De[u]??{id:u,name:`${u[0].toUpperCase()}${u.slice(1)}`,provider:`is${u[0].toUpperCase()}${u.slice(1)}`}}:{id:"injected",name:"Injected",provider(o){return o==null?void 0:o.ethereum}}}let r,a,i,f;return u=>({get icon(){return c().icon},get id(){return c().id},get name(){return c().name},get supportsSimulation(){return Ee.test(this.id.toLowerCase())},type:J.type,async setup(){const o=await this.getProvider();o&&e.target&&(i||(i=this.onConnect.bind(this),o.on("connect",i)),r||(r=this.onAccountsChanged.bind(this),o.on("accountsChanged",r)))},async connect({chainId:o,isReconnecting:g}={}){var _,y,I,m,v,S;const h=await this.getProvider();if(!h)throw new P;let p=[];if(g)p=await this.getAccounts().catch(()=>[]);else if(n)try{p=(m=(I=(y=(_=(await h.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}))[0])==null?void 0:_.caveats)==null?void 0:y[0])==null?void 0:I.value)==null?void 0:m.map(s=>E(s))}catch(C){const s=C;if(s.code===O.code)throw new O(s);if(s.code===T.code)throw s}try{!(p!=null&&p.length)&&!g&&(p=(await h.request({method:"eth_requestAccounts"})).map(l=>E(l))),i&&(h.removeListener("connect",i),i=void 0),r||(r=this.onAccountsChanged.bind(this),h.on("accountsChanged",r)),a||(a=this.onChainChanged.bind(this),h.on("chainChanged",a)),f||(f=this.onDisconnect.bind(this),h.on("disconnect",f));let C=await this.getChainId();if(o&&C!==o){const s=await this.switchChain({chainId:o}).catch(l=>{if(l.code===O.code)throw l;return{id:C}});C=(s==null?void 0:s.id)??C}return n&&await((v=u.storage)==null?void 0:v.removeItem(`${this.id}.disconnected`)),e.target||await((S=u.storage)==null?void 0:S.setItem("injected.connected",!0)),{accounts:p,chainId:C}}catch(C){const s=C;throw s.code===O.code?new O(s):s.code===T.code?new T(s):s}},async disconnect(){var g,h;const o=await this.getProvider();if(!o)throw new P;a&&(o.removeListener("chainChanged",a),a=void 0),f&&(o.removeListener("disconnect",f),f=void 0),i||(i=this.onConnect.bind(this),o.on("connect",i));try{await o.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}n&&await((g=u.storage)==null?void 0:g.setItem(`${this.id}.disconnected`,!0)),e.target||await((h=u.storage)==null?void 0:h.removeItem("injected.connected"))},async getAccounts(){const o=await this.getProvider();if(!o)throw new P;return(await o.request({method:"eth_accounts"})).map(h=>E(h))},async getChainId(){const o=await this.getProvider();if(!o)throw new P;const g=await o.request({method:"eth_chainId"});return Number(g)},async getProvider(){if(typeof window>"u")return;let o;const g=c();return typeof g.provider=="function"?o=g.provider(window):typeof g.provider=="string"?o=z(window,g.provider):o=g.provider,o&&!o.removeListener&&("off"in o&&typeof o.off=="function"?o.removeListener=o.off:o.removeListener=()=>{}),o},async isAuthorized(){var o,g;try{if(n&&await((o=u.storage)==null?void 0:o.getItem(`${this.id}.disconnected`))||!e.target&&!await((g=u.storage)==null?void 0:g.getItem("injected.connected")))return!1;if(!await this.getProvider()){if(t!==void 0&&t!==!1){const y=async()=>(typeof window<"u"&&window.removeEventListener("ethereum#initialized",y),!!await this.getProvider()),I=typeof t=="number"?t:1e3;if(await Promise.race([...typeof window<"u"?[new Promise(v=>window.addEventListener("ethereum#initialized",()=>v(y()),{once:!0}))]:[],new Promise(v=>setTimeout(()=>v(y()),I))]))return!0}throw new P}return!!(await ge(()=>pe(()=>this.getAccounts(),{timeout:100}))).length}catch{return!1}},async switchChain({addEthereumChainParameter:o,chainId:g}){var _,y,I,m;const h=await this.getProvider();if(!h)throw new P;const p=u.chains.find(v=>v.id===g);if(!p)throw new Q(new H);try{return await Promise.all([h.request({method:"wallet_switchEthereumChain",params:[{chainId:X(g)}]}).then(async()=>{await this.getChainId()===g&&u.emitter.emit("change",{chainId:g})}),new Promise(v=>u.emitter.once("change",({chainId:S})=>{S===g&&v()}))]),p}catch(v){const S=v;if(S.code===4902||((y=(_=S==null?void 0:S.data)==null?void 0:_.originalError)==null?void 0:y.code)===4902)try{const{default:C,...s}=p.blockExplorers??{};let l;o!=null&&o.blockExplorerUrls?l=o.blockExplorerUrls:C&&(l=[C.url,...Object.values(s).map(W=>W.url)]);let d;(I=o==null?void 0:o.rpcUrls)!=null&&I.length?d=o.rpcUrls:d=[((m=p.rpcUrls.default)==null?void 0:m.http[0])??""];const w={blockExplorerUrls:l,chainId:X(g),chainName:(o==null?void 0:o.chainName)??p.name,iconUrls:o==null?void 0:o.iconUrls,nativeCurrency:(o==null?void 0:o.nativeCurrency)??p.nativeCurrency,rpcUrls:d};if(await h.request({method:"wallet_addEthereumChain",params:[w]}),await this.getChainId()!==g)throw new O(new Error("User rejected switch after adding network."));return p}catch(C){throw new O(C)}throw S.code===O.code?new O(S):new Q(S)}},async onAccountsChanged(o){var g;if(o.length===0)this.onDisconnect();else if(u.emitter.listenerCount("connect")){const h=(await this.getChainId()).toString();this.onConnect({chainId:h}),n&&await((g=u.storage)==null?void 0:g.removeItem(`${this.id}.disconnected`))}else u.emitter.emit("change",{accounts:o.map(h=>E(h))})},onChainChanged(o){const g=Number(o);u.emitter.emit("change",{chainId:g})},async onConnect(o){const g=await this.getAccounts();if(g.length===0)return;const h=Number(o.chainId);u.emitter.emit("connect",{accounts:g,chainId:h});const p=await this.getProvider();p&&(i&&(p.removeListener("connect",i),i=void 0),r||(r=this.onAccountsChanged.bind(this),p.on("accountsChanged",r)),a||(a=this.onChainChanged.bind(this),p.on("chainChanged",a)),f||(f=this.onDisconnect.bind(this),p.on("disconnect",f)))},async onDisconnect(o){const g=await this.getProvider();o&&o.code===1013&&g&&(await this.getAccounts()).length||(u.emitter.emit("disconnect"),g&&(a&&(g.removeListener("chainChanged",a),a=void 0),f&&(g.removeListener("disconnect",f),f=void 0),i||(i=this.onConnect.bind(this),g.on("connect",i))))}})}function z(e,n){function t(r){return typeof n=="function"?n(r):typeof n=="string"?r[n]:!0}const c=e.ethereum;if(c!=null&&c.providers)return c.providers.find(r=>t(r));if(c&&t(c))return c}const G=256;let D=G,R;function Re(e=11){if(!R||D+e>G*2){R="",D=0;for(let n=0;n<G;n++)R+=(256+Math.random()*256|0).toString(16).substring(1)}return R.substring(D,D+++e)}function st(e){const{multiInjectedProviderDiscovery:n=!0,storage:t=$e({storage:typeof window<"u"&&window.localStorage?window.localStorage:ce}),syncConnectedChain:c=!0,ssr:r,...a}=e,i=typeof window<"u"&&n?be():void 0,f=L(()=>a.chains),u=L(()=>[...a.connectors??[],...r?[]:(i==null?void 0:i.getProviders().map(g))??[]].map(o));function o(s){var w;const l=Oe(Re()),d={...s({emitter:l,chains:f.getState(),storage:t}),emitter:l,uid:l.uid};return l.on("connect",S),(w=d.setup)==null||w.call(d),d}function g(s){const{info:l}=s,d=s.provider;return J({target:{...l,id:l.rdns,provider:d}})}const h=new Map;function p(s={}){const l=s.chainId??m.getState().chainId,d=f.getState().find(b=>b.id===l);if(s.chainId&&!d)throw new H;{const b=h.get(m.getState().chainId);if(b&&!d)return b;if(!d)throw new H}{const b=h.get(l);if(b)return b}let w;if(a.client)w=a.client({chain:d});else{const b=d.id,W=f.getState().map(j=>j.id),M={},Z=Object.entries(a);for(const[j,A]of Z)if(!(j==="chains"||j==="client"||j==="connectors"||j==="transports"))if(typeof A=="object")if(b in A)M[j]=A[b];else{if(W.some(le=>le in A))continue;M[j]=A}else M[j]=A;w=me({...M,chain:d,batch:M.batch??{multicall:!0},transport:j=>a.transports[b]({...j,connectors:u})})}return h.set(l,w),w}function _(){return{chainId:f.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let y;const I="0.0.0-canary-";U.startsWith(I)?y=parseInt(U.replace(I,"")):y=parseInt(U.split(".")[0]??"0");const m=L(fe(t?he(_,{migrate(s,l){if(l===y)return s;const d=_(),w=s&&typeof s=="object"&&"chainId"in s&&typeof s.chainId=="number"?s.chainId:d.chainId;return{...d,chainId:w}},name:"store",partialize(s){return{connections:{__type:"Map",value:Array.from(s.connections.entries()).map(([l,d])=>{const{id:w,name:b,type:W,uid:M}=d.connector;return[l,{...d,connector:{id:w,name:b,type:W,uid:M}}]})},chainId:s.chainId,current:s.current}},skipHydration:r,storage:t,version:y}):_));c&&m.subscribe(({connections:s,current:l})=>{var d;return l?(d=s.get(l))==null?void 0:d.chainId:void 0},s=>{if(f.getState().some(d=>d.id===s))return m.setState(d=>({...d,chainId:s??d.chainId}))}),i==null||i.subscribe(s=>{const l=new Map;for(const w of u.getState())l.set(w.id,!0);const d=[];for(const w of s){const b=o(g(w));l.has(b.id)||d.push(b)}t&&!m.persist.hasHydrated()||u.setState(w=>[...w,...d],!0)});function v(s){m.setState(l=>{const d=l.connections.get(s.uid);return d?{...l,connections:new Map(l.connections).set(s.uid,{accounts:s.accounts??d.accounts,chainId:s.chainId??d.chainId,connector:d.connector})}:l})}function S(s){m.getState().status==="connecting"||m.getState().status==="reconnecting"||m.setState(l=>{const d=u.getState().find(w=>w.uid===s.uid);return d?(d.emitter.listenerCount("connect")&&d.emitter.off("connect",v),d.emitter.listenerCount("change")||d.emitter.on("change",v),d.emitter.listenerCount("disconnect")||d.emitter.on("disconnect",C),{...l,connections:new Map(l.connections).set(s.uid,{accounts:s.accounts,chainId:s.chainId,connector:d}),current:s.uid,status:"connected"}):l})}function C(s){m.setState(l=>{const d=l.connections.get(s.uid);if(d){const b=d.connector;b.emitter.listenerCount("change")&&d.connector.emitter.off("change",v),b.emitter.listenerCount("disconnect")&&d.connector.emitter.off("disconnect",C),b.emitter.listenerCount("connect")||d.connector.emitter.on("connect",S)}if(l.connections.delete(s.uid),l.connections.size===0)return{...l,connections:new Map,current:null,status:"disconnected"};const w=l.connections.values().next().value;return{...l,connections:new Map(l.connections),current:w.connector.uid}})}return{get chains(){return f.getState()},get connectors(){return u.getState()},storage:t,getClient:p,get state(){return m.getState()},setState(s){let l;typeof s=="function"?l=s(m.getState()):l=s;const d=_();typeof l!="object"&&(l=d),Object.keys(d).some(b=>!(b in l))&&(l=d),m.setState(l,!0)},subscribe(s,l,d){return m.subscribe(s,l,d?{...d,fireImmediately:d.emitImmediately}:void 0)},_internal:{mipd:i,store:m,ssr:!!r,syncConnectedChain:c,transports:a.transports,chains:{setState(s){const l=typeof s=="function"?s(f.getState()):s;if(l.length!==0)return f.setState(l,!0)},subscribe(s){return f.subscribe(s)}},connectors:{providerDetailToConnector:g,setup:o,setState(s){return u.setState(typeof s=="function"?s(u.getState()):s,!0)},subscribe(s){return u.subscribe(s)}},events:{change:v,connect:S,disconnect:C}}}}async function xe(e,n){var c;let t;if(typeof n.connector=="function"?t=e._internal.connectors.setup(n.connector):t=n.connector,t.uid===e.state.current)throw new ke;try{e.setState(i=>({...i,status:"connecting"})),t.emitter.emit("message",{type:"connecting"});const r=await t.connect({chainId:n.chainId}),a=r.accounts;return t.emitter.off("connect",e._internal.events.connect),t.emitter.on("change",e._internal.events.change),t.emitter.on("disconnect",e._internal.events.disconnect),await((c=e.storage)==null?void 0:c.setItem("recentConnectorId",t.id)),e.setState(i=>({...i,connections:new Map(i.connections).set(t.uid,{accounts:a,chainId:r.chainId,connector:t}),current:t.uid,status:"connected"})),{accounts:a,chainId:r.chainId}}catch(r){throw e.setState(a=>({...a,status:a.current?"connected":"disconnected"})),r}}async function Ue(e,n={}){var r,a;let t;if(n.connector)t=n.connector;else{const{connections:i,current:f}=e.state,u=i.get(f);t=u==null?void 0:u.connector}const c=e.state.connections;t&&(await t.disconnect(),t.emitter.off("change",e._internal.events.change),t.emitter.off("disconnect",e._internal.events.disconnect),t.emitter.on("connect",e._internal.events.connect),c.delete(t.uid)),e.setState(i=>{if(c.size===0)return{...i,connections:new Map,current:null,status:"disconnected"};const f=c.values().next().value;return{...i,connections:new Map(c),current:f.connector.uid}});{const i=e.state.current;if(!i)return;const f=(r=e.state.connections.get(i))==null?void 0:r.connector;if(!f)return;await((a=e.storage)==null?void 0:a.setItem("recentConnectorId",f.id))}}function ie(e){const n=e.state.current,t=e.state.connections.get(n),c=t==null?void 0:t.accounts,r=c==null?void 0:c[0],a=e.chains.find(f=>f.id===(t==null?void 0:t.chainId)),i=e.state.status;switch(i){case"connected":return{address:r,addresses:c,chain:a,chainId:t==null?void 0:t.chainId,connector:t==null?void 0:t.connector,isConnected:!0,isConnecting:!1,isDisconnected:!1,isReconnecting:!1,status:i};case"reconnecting":return{address:r,addresses:c,chain:a,chainId:t==null?void 0:t.chainId,connector:t==null?void 0:t.connector,isConnected:!!r,isConnecting:!1,isDisconnected:!1,isReconnecting:!0,status:i};case"connecting":return{address:r,addresses:c,chain:a,chainId:t==null?void 0:t.chainId,connector:t==null?void 0:t.connector,isConnected:!1,isConnecting:!0,isDisconnected:!1,isReconnecting:!1,status:i};case"disconnected":return{address:void 0,addresses:void 0,chain:void 0,chainId:void 0,connector:void 0,isConnected:!1,isConnecting:!1,isDisconnected:!0,isReconnecting:!1,status:i}}}function $(e,n){if(e===n)return!0;if(e&&n&&typeof e=="object"&&typeof n=="object"){if(e.constructor!==n.constructor)return!1;let t,c;if(Array.isArray(e)&&Array.isArray(n)){if(t=e.length,t!==n.length)return!1;for(c=t;c--!==0;)if(!$(e[c],n[c]))return!1;return!0}if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===n.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===n.toString();const r=Object.keys(e);if(t=r.length,t!==Object.keys(n).length)return!1;for(c=t;c--!==0;)if(!Object.prototype.hasOwnProperty.call(n,r[c]))return!1;for(c=t;c--!==0;){const a=r[c];if(a&&!$(e[a],n[a]))return!1}return!0}return e!==e&&n!==n}let x=[];function ae(e){const n=[...e.state.connections.values()];return e.state.status==="reconnecting"||$(x,n)?x:(x=n,n)}let F=[];function ze(e){const n=e.connectors;return $(F,n)?F:(F=n,n)}let K=!1;async function qe(e,n={}){var o,g;if(K)return[];K=!0,e.setState(h=>({...h,status:h.current?"reconnecting":"connecting"}));const t=[];if((o=n.connectors)!=null&&o.length)for(const h of n.connectors){let p;typeof h=="function"?p=e._internal.connectors.setup(h):p=h,t.push(p)}else t.push(...e.connectors);let c;try{c=await((g=e.storage)==null?void 0:g.getItem("recentConnectorId"))}catch{}const r={};for(const[,h]of e.state.connections)r[h.connector.id]=1;c&&(r[c]=0);const a=Object.keys(r).length>0?[...t].sort((h,p)=>(r[h.id]??10)-(r[p.id]??10)):t;let i=!1;const f=[],u=[];for(const h of a){const p=await h.getProvider().catch(()=>{});if(!p||u.some(I=>I===p)||!await h.isAuthorized())continue;const y=await h.connect({isReconnecting:!0}).catch(()=>null);y&&(h.emitter.off("connect",e._internal.events.connect),h.emitter.on("change",e._internal.events.change),h.emitter.on("disconnect",e._internal.events.disconnect),e.setState(I=>{const m=new Map(i?I.connections:new Map).set(h.uid,{accounts:y.accounts,chainId:y.chainId,connector:h});return{...I,current:i?I.current:h.uid,connections:m}}),f.push({accounts:y.accounts,chainId:y.chainId,connector:h}),u.push(p),i=!0)}return(e.state.status==="reconnecting"||e.state.status==="connecting")&&(i?e.setState(h=>({...h,status:"connected"})):e.setState(h=>({...h,connections:new Map,current:null,status:"disconnected"}))),K=!1,f}function Be(e,n){const{onChange:t}=n;return e.subscribe(()=>ie(e),t,{equalityFn(c,r){const{connector:a,...i}=c,{connector:f,...u}=r;return $(i,u)&&(a==null?void 0:a.id)===(f==null?void 0:f.id)&&(a==null?void 0:a.uid)===(f==null?void 0:f.uid)}})}function Ne(e,n){const{onChange:t}=n;return e.subscribe(()=>ae(e),t,{equalityFn:$})}function Le(e,n){const{onChange:t}=n;return e._internal.connectors.subscribe((c,r)=>{t(Object.values(c),r)})}function Te(e,n){const{initialState:t,reconnectOnMount:c}=n;return t&&!e._internal.store.persist.hasHydrated()&&e.setState({...t,connections:c?t.connections:new Map,status:c?"reconnecting":"disconnected"}),{async onMount(){var r;if(e._internal.ssr){await e._internal.store.persist.rehydrate();const a=(r=e._internal.mipd)==null?void 0:r.getProviders().map(e._internal.connectors.providerDetailToConnector).map(e._internal.connectors.setup);e._internal.connectors.setState(i=>[...i,...a??[]])}c?qe(e):e.storage&&e.setState(a=>({...a,connections:new Map}))}}}const ue=Symbol(),it={install(e,n){const{config:t,reconnectOnMount:c=!0}=n;e.provide(ue,t);const{onMount:r}=Te(t,{...n,reconnectOnMount:c});r()}},Fe="0.0.10",Ke=()=>`@wagmi/vue@${Fe}`;class de extends N{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiError"})}get docsBaseUrl(){return"https://wagmi.sh/vue"}get version(){return Ke()}}class Ve extends de{constructor(){super("No `config` found in Vue context, use `WagmiPlugin` to properly initialize the library.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiPluginNotFoundError"})}}class He extends de{constructor(){super("Wagmi composables can only be used inside `setup()` function or functions that support injection context.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiInjectionContextError"})}}function Ge(e,n){Object.keys(e).forEach(t=>{e[t]=n[t]})}function k(e={}){const n=ye(e);if(n.config)return n.config;if(!ve())throw new He;const t=Ce(ue);if(!t)throw new Ve;return t}function at(e={}){const n=k(e),t=Ie(ie(n)),c=Be(n,{onChange(r){Ge(t,r)}});return B(()=>c()),Se(te(t))}function Je(e){return{mutationFn(n){return xe(e,n)},mutationKey:["connect"]}}function Ze(e){return{mutationFn(n){return Ue(e,n)},mutationKey:["disconnect"]}}function Qe(e={}){const n=k(e),t=ne(ze(n)),c=Le(n,{onChange(r){t.value=r}});return B(()=>c()),t}function ut(e={}){const{mutation:n}=e,t=k(e),c=Je(t),{mutate:r,mutateAsync:a,...i}=re({...n,...c}),f=t.subscribe(({status:u})=>u,(u,o)=>{o==="connected"&&u==="disconnected"&&i.reset()});return B(()=>f()),{...i,connect:r,connectAsync:a,connectors:Qe({config:t}).value}}function Xe(e={}){const n=k(e),t=ne(ae(n)),c=Ne(n,{onChange(r){t.value=r}});return B(()=>c()),te(t)}function dt(e={}){const{mutation:n}=e,t=k(e),c=Xe({config:t}),r=Ze(t),{mutate:a,mutateAsync:i,...f}=re({...n,...r});return{...f,connectors:_e(()=>c.value.map(u=>u.connector)),disconnect:a,disconnectAsync:i}}export{it as W,dt as a,at as b,st as c,ut as u};
