const __vite__fileDeps=["assets/@walletconnect-Cf5wJyuV.js","assets/@stablelib-B519yloO.js","assets/@babel-VbPd-4M3.js","assets/multiformats-DSKVg-N-.js","assets/events-BHFBkAHP.js","assets/detect-browser-ClY_l-h2.js","assets/tslib-CoNcODE4.js","assets/query-string-SCOpAa9y.js","assets/strict-uri-encode-DdzwWRIL.js","assets/decode-uri-component-CROxjmim.js","assets/split-on-first-BNP3K2Fc.js","assets/filter-obj-DG2z_hf8.js","assets/uint8arrays-BSAB2j_x.js","assets/unstorage-I5IaDmqs.js","assets/destr-CVtkxrq9.js","assets/idb-keyval-nibyPLVP.js","assets/pino-Cra013RC.js","assets/quick-format-unescaped-Dys6CG9o.js","assets/lodash.isequal-cb4NOOgA.js","assets/isomorphic-unfetch-DzflogNS.js","assets/unfetch-D6v4VzSN.js","assets/cross-fetch-aPGaTLN9.js","assets/@lit-DjZwrzog.js","assets/lit-html-DfFMVDgK.js","assets/lit-element-Cx71in3k.js","assets/valtio-CyFKDiGU.js","assets/proxy-compare-DDw08AJZ.js","assets/qrcode-CGiDONbL.js","assets/encode-utf8-Cn5aGd7v.js","assets/dijkstrajs-D_NXgYpA.js","assets/motion-NW9MFZdV.js","assets/@motionone-BkHL0rzb.js","assets/zustand-CsM-6wGT.js","assets/viem-DzESpT6j.js","assets/eventemitter3-1nPwmqHx.js","assets/mipd-CIcDX0W7.js","assets/@vue-CyX75HH2.js","assets/@tanstack-Y25bY9CG.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{c as H,s as Ut,p as Nt}from"./zustand-CsM-6wGT.js";import{g as M,U as j,R as J,w as Rt,a as Dt,S as X,n as F,c as pt,p as xt,b as Et,d as Wt,m as Lt,r as Bt,C as gt,h as Tt,t as Ft,f as mt,e as Kt,s as zt,i as Qt}from"./viem-DzESpT6j.js";import{E as Vt}from"./eventemitter3-1nPwmqHx.js";import{c as Ht}from"./mipd-CIcDX0W7.js";import{u as K,h as Jt,i as Gt,b as Zt,t as Xt,d as nt,o as D,a as yt,c as N,r as st}from"./@vue-CyX75HH2.js";import{r as Yt,u as te,a as rt}from"./@tanstack-Y25bY9CG.js";const ee="modulepreload",ne=function(t){return"/hackaton/"+t},ut={},se=function(n,e,s){let r=Promise.resolve();if(e&&e.length>0){document.getElementsByTagName("link");const i=document.querySelector("meta[property=csp-nonce]"),a=(i==null?void 0:i.nonce)||(i==null?void 0:i.getAttribute("nonce"));r=Promise.all(e.map(u=>{if(u=ne(u),u in ut)return;ut[u]=!0;const l=u.endsWith(".css"),o=l?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${u}"]${o}`))return;const h=document.createElement("link");if(h.rel=l?"stylesheet":ee,l||(h.as="script",h.crossOrigin=""),h.href=u,a&&h.setAttribute("nonce",a),document.head.appendChild(h),l)return new Promise((d,c)=>{h.addEventListener("load",d),h.addEventListener("error",()=>c(new Error(`Unable to preload CSS for ${u}`)))})}))}return r.then(()=>n()).catch(i=>{const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=i,window.dispatchEvent(a),!a.defaultPrevented)throw i})};class re{constructor(n){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new Vt})}on(n,e){this._emitter.on(n,e)}once(n,e){this._emitter.once(n,e)}off(n,e){this._emitter.off(n,e)}emit(n,...e){const s=e[0];this._emitter.emit(n,{uid:this.uid,...s})}listenerCount(n){return this._emitter.listenerCount(n)}}function ie(t){return new re(t)}function oe(t,n){return JSON.parse(t,(e,s)=>{let r=s;return(r==null?void 0:r.__type)==="bigint"&&(r=BigInt(r.value)),(r==null?void 0:r.__type)==="Map"&&(r=new Map(r.value)),(n==null?void 0:n(e,r))??r})}function lt(t,n){return t.slice(0,n).join(".")||"."}function dt(t,n){const{length:e}=t;for(let s=0;s<e;++s)if(t[s]===n)return s+1;return 0}function ce(t,n){const e=typeof t=="function",s=typeof n=="function",r=[],i=[];return function(u,l){if(typeof l=="object")if(r.length){const o=dt(r,this);o===0?r[r.length]=this:(r.splice(o),i.splice(o)),i[i.length]=u;const h=dt(r,l);if(h!==0)return s?n.call(this,u,l,lt(i,h)):`[ref=${lt(i,h)}]`}else r[0]=l,i[0]=u;return e?t.call(this,u,l):l}}function ae(t,n,e,s){return JSON.stringify(t,ce((r,i)=>{let a=i;return typeof a=="bigint"&&(a={__type:"bigint",value:i.toString()}),a instanceof Map&&(a={__type:"Map",value:Array.from(i.entries())}),(n==null?void 0:n(r,a))??a},s),e??void 0)}function ue(t){const{deserialize:n=oe,key:e="wagmi",serialize:s=ae,storage:r=wt}=t;function i(a){return a instanceof Promise?a.then(u=>u).catch(()=>null):a}return{...r,key:e,async getItem(a,u){const l=r.getItem(`${e}.${a}`),o=await i(l);return o?n(o)??null:u??null},async setItem(a,u){const l=`${e}.${a}`;u===null?await i(r.removeItem(l)):await i(r.setItem(l,s(u)))},async removeItem(a){await i(r.removeItem(`${e}.${a}`))}}}const wt={getItem:()=>null,setItem:()=>{},removeItem:()=>{}};const B="2.10.4",le=()=>`@wagmi/core@${B}`;var bt=function(t,n,e,s){if(e==="a"&&!s)throw new TypeError("Private accessor was defined without a getter");if(typeof n=="function"?t!==n||!s:!n.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return e==="m"?s:e==="a"?s.call(t):s?s.value:n.get(t)},z,Ct;let R=class Y extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return le()}constructor(n,e={}){var i;super(),z.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});const s=e.cause instanceof Y?e.cause.details:(i=e.cause)!=null&&i.message?e.cause.message:e.details,r=e.cause instanceof Y&&e.cause.docsPath||e.docsPath;this.message=[n||"An error occurred.","",...e.metaMessages?[...e.metaMessages,""]:[],...r?[`Docs: ${this.docsBaseUrl}${r}.html${e.docsSlug?`#${e.docsSlug}`:""}`]:[],...s?[`Details: ${s}`]:[],`Version: ${this.version}`].join(`
`),e.cause&&(this.cause=e.cause),this.details=s,this.docsPath=r,this.metaMessages=e.metaMessages,this.shortMessage=n}walk(n){return bt(this,z,"m",Ct).call(this,this,n)}};z=new WeakSet,Ct=function t(n,e){return e!=null&&e(n)?n:n.cause?bt(this,z,"m",t).call(this,n.cause,e):n};class Q extends R{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}}class de extends R{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}}class fe extends R{constructor(){super("Connector not connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}}class he extends R{constructor({address:n,connector:e}){super(`Account "${n}" not found for connector "${e.name}".`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}}class P extends R{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}}const pe=/(rabby|trustwallet)/,ge={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider(t){return t!=null&&t.coinbaseWalletExtension?t.coinbaseWalletExtension:T(t,"isCoinbaseWallet")}},metaMask:{id:"metaMask",name:"MetaMask",provider(t){return T(t,n=>{if(!n.isMetaMask||n.isBraveWallet&&!n._events&&!n._state)return!1;const e=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPortal","isRabby","isTokenPocket","isTokenary","isZerion"];for(const s of e)if(n[s])return!1;return!0})}},phantom:{id:"phantom",name:"Phantom",provider(t){var n,e;return(n=t==null?void 0:t.phantom)!=null&&n.ethereum?(e=t.phantom)==null?void 0:e.ethereum:T(t,"isPhantom")}}};it.type="injected";function it(t={}){const{shimDisconnect:n=!0,unstable_shimAsyncInject:e}=t;function s(){const l=t.target;if(typeof l=="function"){const o=l();if(o)return o}return typeof l=="object"?l:typeof l=="string"?{...ge[l]??{id:l,name:`${l[0].toUpperCase()}${l.slice(1)}`,provider:`is${l[0].toUpperCase()}${l.slice(1)}`}}:{id:"injected",name:"Injected",provider(o){return o==null?void 0:o.ethereum}}}let r,i,a,u;return l=>({get icon(){return s().icon},get id(){return s().id},get name(){return s().name},get supportsSimulation(){return pe.test(this.id.toLowerCase())},type:it.type,async setup(){const o=await this.getProvider();o&&t.target&&(a||(a=this.onConnect.bind(this),o.on("connect",a)),r||(r=this.onAccountsChanged.bind(this),o.on("accountsChanged",r)))},async connect({chainId:o,isReconnecting:h}={}){var m,w,b,y,C,_;const d=await this.getProvider();if(!d)throw new P;let c=[];if(h)c=await this.getAccounts().catch(()=>[]);else if(n)try{c=(y=(b=(w=(m=(await d.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}))[0])==null?void 0:m.caveats)==null?void 0:w[0])==null?void 0:b.value)==null?void 0:y.map(f=>M(f))}catch(I){const f=I;if(f.code===j.code)throw new j(f);if(f.code===J.code)throw f}try{!(c!=null&&c.length)&&!h&&(c=(await d.request({method:"eth_requestAccounts"})).map(p=>M(p))),a&&(d.removeListener("connect",a),a=void 0),r||(r=this.onAccountsChanged.bind(this),d.on("accountsChanged",r)),i||(i=this.onChainChanged.bind(this),d.on("chainChanged",i)),u||(u=this.onDisconnect.bind(this),d.on("disconnect",u));let I=await this.getChainId();if(o&&I!==o){const f=await this.switchChain({chainId:o}).catch(p=>{if(p.code===j.code)throw p;return{id:I}});I=(f==null?void 0:f.id)??I}return n&&await((C=l.storage)==null?void 0:C.removeItem(`${this.id}.disconnected`)),t.target||await((_=l.storage)==null?void 0:_.setItem("injected.connected",!0)),{accounts:c,chainId:I}}catch(I){const f=I;throw f.code===j.code?new j(f):f.code===J.code?new J(f):f}},async disconnect(){var h,d;const o=await this.getProvider();if(!o)throw new P;i&&(o.removeListener("chainChanged",i),i=void 0),u&&(o.removeListener("disconnect",u),u=void 0),a||(a=this.onConnect.bind(this),o.on("connect",a));try{await o.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}n&&await((h=l.storage)==null?void 0:h.setItem(`${this.id}.disconnected`,!0)),t.target||await((d=l.storage)==null?void 0:d.removeItem("injected.connected"))},async getAccounts(){const o=await this.getProvider();if(!o)throw new P;return(await o.request({method:"eth_accounts"})).map(d=>M(d))},async getChainId(){const o=await this.getProvider();if(!o)throw new P;const h=await o.request({method:"eth_chainId"});return Number(h)},async getProvider(){if(typeof window>"u")return;let o;const h=s();return typeof h.provider=="function"?o=h.provider(window):typeof h.provider=="string"?o=T(window,h.provider):o=h.provider,o&&!o.removeListener&&("off"in o&&typeof o.off=="function"?o.removeListener=o.off:o.removeListener=()=>{}),o},async isAuthorized(){var o,h;try{if(n&&await((o=l.storage)==null?void 0:o.getItem(`${this.id}.disconnected`))||!t.target&&!await((h=l.storage)==null?void 0:h.getItem("injected.connected")))return!1;if(!await this.getProvider()){if(e!==void 0&&e!==!1){const w=async()=>(typeof window<"u"&&window.removeEventListener("ethereum#initialized",w),!!await this.getProvider()),b=typeof e=="number"?e:1e3;if(await Promise.race([...typeof window<"u"?[new Promise(C=>window.addEventListener("ethereum#initialized",()=>C(w()),{once:!0}))]:[],new Promise(C=>setTimeout(()=>C(w()),b))]))return!0}throw new P}return!!(await Rt(()=>Dt(()=>this.getAccounts(),{timeout:100}))).length}catch{return!1}},async switchChain({addEthereumChainParameter:o,chainId:h}){var m,w,b,y;const d=await this.getProvider();if(!d)throw new P;const c=l.chains.find(C=>C.id===h);if(!c)throw new X(new Q);try{return await Promise.all([d.request({method:"wallet_switchEthereumChain",params:[{chainId:F(h)}]}).then(async()=>{await this.getChainId()===h&&l.emitter.emit("change",{chainId:h})}),new Promise(C=>l.emitter.once("change",({chainId:_})=>{_===h&&C()}))]),c}catch(C){const _=C;if(_.code===4902||((w=(m=_==null?void 0:_.data)==null?void 0:m.originalError)==null?void 0:w.code)===4902)try{const{default:I,...f}=c.blockExplorers??{};let p;o!=null&&o.blockExplorerUrls?p=o.blockExplorerUrls:I&&(p=[I.url,...Object.values(f).map(U=>U.url)]);let g;(b=o==null?void 0:o.rpcUrls)!=null&&b.length?g=o.rpcUrls:g=[((y=c.rpcUrls.default)==null?void 0:y.http[0])??""];const v={blockExplorerUrls:p,chainId:F(h),chainName:(o==null?void 0:o.chainName)??c.name,iconUrls:o==null?void 0:o.iconUrls,nativeCurrency:(o==null?void 0:o.nativeCurrency)??c.nativeCurrency,rpcUrls:g};if(await d.request({method:"wallet_addEthereumChain",params:[v]}),await this.getChainId()!==h)throw new j(new Error("User rejected switch after adding network."));return c}catch(I){throw new j(I)}throw _.code===j.code?new j(_):new X(_)}},async onAccountsChanged(o){var h;if(o.length===0)this.onDisconnect();else if(l.emitter.listenerCount("connect")){const d=(await this.getChainId()).toString();this.onConnect({chainId:d}),n&&await((h=l.storage)==null?void 0:h.removeItem(`${this.id}.disconnected`))}else l.emitter.emit("change",{accounts:o.map(d=>M(d))})},onChainChanged(o){const h=Number(o);l.emitter.emit("change",{chainId:h})},async onConnect(o){const h=await this.getAccounts();if(h.length===0)return;const d=Number(o.chainId);l.emitter.emit("connect",{accounts:h,chainId:d});const c=await this.getProvider();c&&(a&&(c.removeListener("connect",a),a=void 0),r||(r=this.onAccountsChanged.bind(this),c.on("accountsChanged",r)),i||(i=this.onChainChanged.bind(this),c.on("chainChanged",i)),u||(u=this.onDisconnect.bind(this),c.on("disconnect",u)))},async onDisconnect(o){const h=await this.getProvider();o&&o.code===1013&&h&&(await this.getAccounts()).length||(l.emitter.emit("disconnect"),h&&(i&&(h.removeListener("chainChanged",i),i=void 0),u&&(h.removeListener("disconnect",u),u=void 0),a||(a=this.onConnect.bind(this),h.on("connect",a))))}})}function T(t,n){function e(r){return typeof n=="function"?n(r):typeof n=="string"?r[n]:!0}const s=t.ethereum;if(s!=null&&s.providers)return s.providers.find(r=>e(r));if(s&&e(s))return s}const tt=256;let E=tt,W;function me(t=11){if(!W||E+t>tt*2){W="",E=0;for(let n=0;n<tt;n++)W+=(256+Math.random()*256|0).toString(16).substring(1)}return W.substring(E,E+++t)}function cn(t){const{multiInjectedProviderDiscovery:n=!0,storage:e=ue({storage:typeof window<"u"&&window.localStorage?window.localStorage:wt}),syncConnectedChain:s=!0,ssr:r,...i}=t,a=typeof window<"u"&&n?Ht():void 0,u=H(()=>i.chains),l=H(()=>[...i.connectors??[],...r?[]:(a==null?void 0:a.getProviders().map(h))??[]].map(o));function o(f){var v;const p=ie(me()),g={...f({emitter:p,chains:u.getState(),storage:e}),emitter:p,uid:p.uid};return p.on("connect",_),(v=g.setup)==null||v.call(g),g}function h(f){const{info:p}=f,g=f.provider;return it({target:{...p,id:p.rdns,provider:g}})}const d=new Map;function c(f={}){const p=f.chainId??y.getState().chainId,g=u.getState().find(S=>S.id===p);if(f.chainId&&!g)throw new Q;{const S=d.get(y.getState().chainId);if(S&&!g)return S;if(!g)throw new Q}{const S=d.get(p);if(S)return S}let v;if(i.client)v=i.client({chain:g});else{const S=g.id,U=u.getState().map(O=>O.id),q={},V=Object.entries(i);for(const[O,k]of V)if(!(O==="chains"||O==="client"||O==="connectors"||O==="transports"))if(typeof k=="object")if(S in k)q[O]=k[S];else{if(U.some(at=>at in k))continue;q[O]=k}else q[O]=k;v=pt({...q,chain:g,batch:q.batch??{multicall:!0},transport:O=>i.transports[S]({...O,connectors:l})})}return d.set(p,v),v}function m(){return{chainId:u.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let w;const b="0.0.0-canary-";B.startsWith(b)?w=parseInt(B.replace(b,"")):w=parseInt(B.split(".")[0]??"0");const y=H(Ut(e?Nt(m,{migrate(f,p){if(p===w)return f;const g=m(),v=f&&typeof f=="object"&&"chainId"in f&&typeof f.chainId=="number"?f.chainId:g.chainId;return{...g,chainId:v}},name:"store",partialize(f){return{connections:{__type:"Map",value:Array.from(f.connections.entries()).map(([p,g])=>{const{id:v,name:S,type:U,uid:q}=g.connector;return[p,{...g,connector:{id:v,name:S,type:U,uid:q}}]})},chainId:f.chainId,current:f.current}},skipHydration:r,storage:e,version:w}):m));s&&y.subscribe(({connections:f,current:p})=>{var g;return p?(g=f.get(p))==null?void 0:g.chainId:void 0},f=>{if(u.getState().some(g=>g.id===f))return y.setState(g=>({...g,chainId:f??g.chainId}))}),a==null||a.subscribe(f=>{const p=new Map;for(const v of l.getState())p.set(v.id,!0);const g=[];for(const v of f){const S=o(h(v));p.has(S.id)||g.push(S)}e&&!y.persist.hasHydrated()||l.setState(v=>[...v,...g],!0)});function C(f){y.setState(p=>{const g=p.connections.get(f.uid);return g?{...p,connections:new Map(p.connections).set(f.uid,{accounts:f.accounts??g.accounts,chainId:f.chainId??g.chainId,connector:g.connector})}:p})}function _(f){y.getState().status==="connecting"||y.getState().status==="reconnecting"||y.setState(p=>{const g=l.getState().find(v=>v.uid===f.uid);return g?(g.emitter.listenerCount("connect")&&g.emitter.off("connect",C),g.emitter.listenerCount("change")||g.emitter.on("change",C),g.emitter.listenerCount("disconnect")||g.emitter.on("disconnect",I),{...p,connections:new Map(p.connections).set(f.uid,{accounts:f.accounts,chainId:f.chainId,connector:g}),current:f.uid,status:"connected"}):p})}function I(f){y.setState(p=>{const g=p.connections.get(f.uid);if(g){const S=g.connector;S.emitter.listenerCount("change")&&g.connector.emitter.off("change",C),S.emitter.listenerCount("disconnect")&&g.connector.emitter.off("disconnect",I),S.emitter.listenerCount("connect")||g.connector.emitter.on("connect",_)}if(p.connections.delete(f.uid),p.connections.size===0)return{...p,connections:new Map,current:null,status:"disconnected"};const v=p.connections.values().next().value;return{...p,connections:new Map(p.connections),current:v.connector.uid}})}return{get chains(){return u.getState()},get connectors(){return l.getState()},storage:e,getClient:c,get state(){return y.getState()},setState(f){let p;typeof f=="function"?p=f(y.getState()):p=f;const g=m();typeof p!="object"&&(p=g),Object.keys(g).some(S=>!(S in p))&&(p=g),y.setState(p,!0)},subscribe(f,p,g){return y.subscribe(f,p,g?{...g,fireImmediately:g.emitImmediately}:void 0)},_internal:{mipd:a,store:y,ssr:!!r,syncConnectedChain:s,transports:i.transports,chains:{setState(f){const p=typeof f=="function"?f(u.getState()):f;if(p.length!==0)return u.setState(p,!0)},subscribe(f){return u.subscribe(f)}},connectors:{providerDetailToConnector:h,setup:o,setState(f){return l.setState(typeof f=="function"?f(l.getState()):f,!0)},subscribe(f){return l.subscribe(f)}},events:{change:C,connect:_,disconnect:I}}}}function x(t,n,e){const s=t[n.name];if(typeof s=="function")return s;const r=t[e];return typeof r=="function"?r:i=>n(t,i)}async function ye(t,n){var s;let e;if(typeof n.connector=="function"?e=t._internal.connectors.setup(n.connector):e=n.connector,e.uid===t.state.current)throw new de;try{t.setState(a=>({...a,status:"connecting"})),e.emitter.emit("message",{type:"connecting"});const r=await e.connect({chainId:n.chainId}),i=r.accounts;return e.emitter.off("connect",t._internal.events.connect),e.emitter.on("change",t._internal.events.change),e.emitter.on("disconnect",t._internal.events.disconnect),await((s=t.storage)==null?void 0:s.setItem("recentConnectorId",e.id)),t.setState(a=>({...a,connections:new Map(a.connections).set(e.uid,{accounts:i,chainId:r.chainId,connector:e}),current:e.uid,status:"connected"})),{accounts:i,chainId:r.chainId}}catch(r){throw t.setState(i=>({...i,status:i.current?"connected":"disconnected"})),r}}async function we(t,n={}){var r,i;let e;if(n.connector)e=n.connector;else{const{connections:a,current:u}=t.state,l=a.get(u);e=l==null?void 0:l.connector}const s=t.state.connections;e&&(await e.disconnect(),e.emitter.off("change",t._internal.events.change),e.emitter.off("disconnect",t._internal.events.disconnect),e.emitter.on("connect",t._internal.events.connect),s.delete(e.uid)),t.setState(a=>{if(s.size===0)return{...a,connections:new Map,current:null,status:"disconnected"};const u=s.values().next().value;return{...a,connections:new Map(s),current:u.connector.uid}});{const a=t.state.current;if(!a)return;const u=(r=t.state.connections.get(a))==null?void 0:r.connector;if(!u)return;await((i=t.storage)==null?void 0:i.setItem("recentConnectorId",u.id))}}async function vt(t,n={}){let e;if(n.connector){const{connector:l}=n,[o,h]=await Promise.all([l.getAccounts(),l.getChainId()]);e={accounts:o,chainId:h,connector:l}}else e=t.state.connections.get(t.state.current);if(!e)throw new fe;const s=n.chainId??e.chainId,r=e.connector;if(r.getClient)return r.getClient({chainId:s});const i=xt(n.account??e.accounts[0]);i.address=M(i.address);const a=t.chains.find(l=>l.id===s),u=await e.connector.getProvider({chainId:s});if(n.account&&!e.accounts.some(l=>l.toLowerCase()===i.address.toLowerCase()))throw new he({address:i.address,connector:r});return pt({account:i,chain:a,name:"Connector Client",transport:l=>Et(u)({...l,retryCount:0})})}function It(t){return typeof t=="number"?t:t==="wei"?0:Math.abs(Wt[t])}function ot(t){const n=t.state.current,e=t.state.connections.get(n),s=e==null?void 0:e.accounts,r=s==null?void 0:s[0],i=t.chains.find(u=>u.id===(e==null?void 0:e.chainId)),a=t.state.status;switch(a){case"connected":return{address:r,addresses:s,chain:i,chainId:e==null?void 0:e.chainId,connector:e==null?void 0:e.connector,isConnected:!0,isConnecting:!1,isDisconnected:!1,isReconnecting:!1,status:a};case"reconnecting":return{address:r,addresses:s,chain:i,chainId:e==null?void 0:e.chainId,connector:e==null?void 0:e.connector,isConnected:!!r,isConnecting:!1,isDisconnected:!1,isReconnecting:!0,status:a};case"connecting":return{address:r,addresses:s,chain:i,chainId:e==null?void 0:e.chainId,connector:e==null?void 0:e.connector,isConnected:!1,isConnecting:!0,isDisconnected:!1,isReconnecting:!1,status:a};case"disconnected":return{address:void 0,addresses:void 0,chain:void 0,chainId:void 0,connector:void 0,isConnected:!1,isConnecting:!1,isDisconnected:!0,isReconnecting:!1,status:a}}}async function be(t,n){const{allowFailure:e=!0,chainId:s,contracts:r,...i}=n,a=t.getClient({chainId:s});return x(a,Lt,"multicall")({allowFailure:e,contracts:r,...i})}function St(t,n){const{chainId:e,...s}=n,r=t.getClient({chainId:e});return x(r,Bt,"readContract")(s)}async function Ce(t,n){const{allowFailure:e=!0,blockNumber:s,blockTag:r,...i}=n,a=n.contracts;try{const u=a.reduce((d,c,m)=>{const w=c.chainId??t.state.chainId;return{...d,[w]:[...d[w]||[],{contract:c,index:m}]}},{}),l=()=>Object.entries(u).map(([d,c])=>be(t,{...i,allowFailure:e,blockNumber:s,blockTag:r,chainId:parseInt(d),contracts:c.map(({contract:m})=>m)})),o=(await Promise.all(l())).flat(),h=Object.values(u).flatMap(d=>d.map(({index:c})=>c));return o.reduce((d,c,m)=>(d&&(d[h[m]]=c),d),[])}catch(u){if(u instanceof gt)throw u;const l=()=>a.map(o=>St(t,{...o,blockNumber:s,blockTag:r}));return e?(await Promise.allSettled(l())).map(o=>o.status==="fulfilled"?{result:o.value,status:"success"}:{error:o.reason,result:void 0,status:"failure"}):await Promise.all(l())}}async function ve(t,n){const{address:e,blockNumber:s,blockTag:r,chainId:i,token:a,unit:u="ether"}=n;if(a)try{return ft(t,{balanceAddress:e,chainId:i,symbolType:"string",tokenAddress:a})}catch(c){if(c instanceof gt){const m=await ft(t,{balanceAddress:e,chainId:i,symbolType:"bytes32",tokenAddress:a}),w=Tt(Ft(m.symbol,{dir:"right"}));return{...m,symbol:w}}throw c}const l=t.getClient({chainId:i}),h=await x(l,Kt,"getBalance")(s?{address:e,blockNumber:s}:{address:e,blockTag:r}),d=t.chains.find(c=>c.id===i)??l.chain;return{decimals:d.nativeCurrency.decimals,formatted:mt(h,It(u)),symbol:d.nativeCurrency.symbol,value:h}}async function ft(t,n){const{balanceAddress:e,chainId:s,symbolType:r,tokenAddress:i,unit:a}=n,u={abi:[{type:"function",name:"balanceOf",stateMutability:"view",inputs:[{type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:r}]}],address:i},[l,o,h]=await Ce(t,{allowFailure:!1,contracts:[{...u,functionName:"balanceOf",args:[e],chainId:s},{...u,functionName:"decimals",chainId:s},{...u,functionName:"symbol",chainId:s}]}),d=mt(l??"0",It(a??o));return{decimals:o,formatted:d,symbol:h,value:l}}function Ie(t){return t.state.chainId}function $(t,n){if(t===n)return!0;if(t&&n&&typeof t=="object"&&typeof n=="object"){if(t.constructor!==n.constructor)return!1;let e,s;if(Array.isArray(t)&&Array.isArray(n)){if(e=t.length,e!==n.length)return!1;for(s=e;s--!==0;)if(!$(t[s],n[s]))return!1;return!0}if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();const r=Object.keys(t);if(e=r.length,e!==Object.keys(n).length)return!1;for(s=e;s--!==0;)if(!Object.prototype.hasOwnProperty.call(n,r[s]))return!1;for(s=e;s--!==0;){const i=r[s];if(i&&!$(t[i],n[i]))return!1}return!0}return t!==t&&n!==n}let L=[];function _t(t){const n=[...t.state.connections.values()];return t.state.status==="reconnecting"||$(L,n)?L:(L=n,n)}let G=[];function Se(t){const n=t.connectors;return $(G,n)?G:(G=n,n)}let Z=!1;async function _e(t,n={}){var o,h;if(Z)return[];Z=!0,t.setState(d=>({...d,status:d.current?"reconnecting":"connecting"}));const e=[];if((o=n.connectors)!=null&&o.length)for(const d of n.connectors){let c;typeof d=="function"?c=t._internal.connectors.setup(d):c=d,e.push(c)}else e.push(...t.connectors);let s;try{s=await((h=t.storage)==null?void 0:h.getItem("recentConnectorId"))}catch{}const r={};for(const[,d]of t.state.connections)r[d.connector.id]=1;s&&(r[s]=0);const i=Object.keys(r).length>0?[...e].sort((d,c)=>(r[d.id]??10)-(r[c.id]??10)):e;let a=!1;const u=[],l=[];for(const d of i){const c=await d.getProvider().catch(()=>{});if(!c||l.some(b=>b===c)||!await d.isAuthorized())continue;const w=await d.connect({isReconnecting:!0}).catch(()=>null);w&&(d.emitter.off("connect",t._internal.events.connect),d.emitter.on("change",t._internal.events.change),d.emitter.on("disconnect",t._internal.events.disconnect),t.setState(b=>{const y=new Map(a?b.connections:new Map).set(d.uid,{accounts:w.accounts,chainId:w.chainId,connector:d});return{...b,current:a?b.current:d.uid,connections:y}}),u.push({accounts:w.accounts,chainId:w.chainId,connector:d}),l.push(c),a=!0)}return(t.state.status==="reconnecting"||t.state.status==="connecting")&&(a?t.setState(d=>({...d,status:"connected"})):t.setState(d=>({...d,connections:new Map,current:null,status:"disconnected"}))),Z=!1,u}async function Oe(t,n){const{abi:e,chainId:s,connector:r,...i}=n;let a;n.account?a=n.account:a=(await vt(t,{chainId:s,connector:r})).account;const u=t.getClient({chainId:s}),l=x(u,zt,"simulateContract"),{result:o,request:h}=await l({...i,abi:e,account:a});return{chainId:u.chain.id,result:o,request:{__mode:"prepared",...h,chainId:s}}}function je(t,n){const{onChange:e}=n;return t.subscribe(()=>ot(t),e,{equalityFn(s,r){const{connector:i,...a}=s,{connector:u,...l}=r;return $(a,l)&&(i==null?void 0:i.id)===(u==null?void 0:u.id)&&(i==null?void 0:i.uid)===(u==null?void 0:u.uid)}})}function Ae(t,n){const{onChange:e}=n;return t.subscribe(s=>s.chainId,e)}function qe(t,n){const{onChange:e}=n;return t.subscribe(()=>_t(t),e,{equalityFn:$})}function Pe(t,n){const{onChange:e}=n;return t._internal.connectors.subscribe((s,r)=>{e(Object.values(s),r)})}async function Me(t,n){const{account:e,chainId:s,connector:r,__mode:i,...a}=n;let u;typeof e=="object"&&e.type==="local"?u=t.getClient({chainId:s}):u=await vt(t,{account:e,chainId:s,connector:r});const{connector:l}=ot(t);let o;if(i==="prepared"||l!=null&&l.supportsSimulation)o=a;else{const{request:c}=await Oe(t,{...a,account:e,chainId:s});o=c}return await x(u,Qt,"writeContract")({...o,...e?{account:e}:{},chain:s?{id:s}:null})}function ke(t,n){const{initialState:e,reconnectOnMount:s}=n;return e&&!t._internal.store.persist.hasHydrated()&&t.setState({...e,connections:s?e.connections:new Map,status:s?"reconnecting":"disconnected"}),{async onMount(){var r;if(t._internal.ssr){await t._internal.store.persist.rehydrate();const i=(r=t._internal.mipd)==null?void 0:r.getProviders().map(t._internal.connectors.providerDetailToConnector).map(t._internal.connectors.setup);t._internal.connectors.setState(a=>[...a,...i??[]])}s?_e(t):t.storage&&t.setState(i=>({...i,connections:new Map}))}}}const Ot=Symbol(),an={install(t,n){const{config:e,reconnectOnMount:s=!0}=n;t.provide(Ot,e);const{onMount:r}=ke(e,{...n,reconnectOnMount:s});r()}},$e="0.0.10",Ue=()=>`@wagmi/vue@${$e}`;class jt extends R{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiError"})}get docsBaseUrl(){return"https://wagmi.sh/vue"}get version(){return Ue()}}class Ne extends jt{constructor(){super("No `config` found in Vue context, use `WagmiPlugin` to properly initialize the library.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiPluginNotFoundError"})}}class Re extends jt{constructor(){super("Wagmi composables can only be used inside `setup()` function or functions that support injection context.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiInjectionContextError"})}}function De(t,n){Object.keys(t).forEach(e=>{t[e]=n[e]})}function A(t={}){const n=K(t);if(n.config)return n.config;if(!Jt())throw new Re;const e=Gt(Ot);if(!e)throw new Ne;return e}function un(t={}){const n=A(t),e=Zt(ot(n)),s=je(n,{onChange(r){De(e,r)}});return D(()=>s()),Xt(nt(e))}function et(t,n){if(n){const e=n(t);if(e===void 0&&yt(t)||e!==void 0)return e}if(Array.isArray(t))return t.map(e=>et(e,n));if(typeof t=="object"&&xe(t)){const e=Object.entries(t).map(([s,r])=>[s,et(r,n)]);return Object.fromEntries(e)}return t}function ct(t){return et(t,n=>{if(yt(n))return ct(K(n))})}function xe(t){if(Object.prototype.toString.call(t)!=="[object Object]")return!1;const n=Object.getPrototypeOf(t);return n===null||n===Object.prototype}function Ee(t,n){return $(t,n)?t:Yt(t,n)}function We(t){return JSON.stringify(t,(n,e)=>Le(e)?Object.keys(e).sort().reduce((s,r)=>(s[r]=e[r],s),{}):typeof e=="bigint"?e.toString():e)}function Le(t){if(!ht(t))return!1;const n=t.constructor;if(typeof n>"u")return!0;const e=n.prototype;return!(!ht(e)||!e.hasOwnProperty("isPrototypeOf"))}function ht(t){return Object.prototype.toString.call(t)==="[object Object]"}function At(t){const{_defaulted:n,behavior:e,gcTime:s,initialData:r,initialDataUpdatedAt:i,maxPages:a,meta:u,networkMode:l,queryFn:o,queryHash:h,queryKey:d,queryKeyHashFn:c,retry:m,retryDelay:w,structuralSharing:b,getPreviousPageParam:y,getNextPageParam:C,initialPageParam:_,_optimisticResults:I,enabled:f,notifyOnChangeProps:p,placeholderData:g,refetchInterval:v,refetchIntervalInBackground:S,refetchOnMount:U,refetchOnReconnect:q,refetchOnWindowFocus:V,retryOnMount:O,select:k,staleTime:kt,suspense:at,throwOnError:Ge,config:Ze,connector:Xe,query:Ye,...$t}=t;return $t}function Be(t){return{mutationFn(n){return ye(t,n)},mutationKey:["connect"]}}function Te(t){return{mutationFn(n){return we(t,n)},mutationKey:["disconnect"]}}function Fe(t,n={}){return{async queryFn({queryKey:e}){const{address:s,scopeKey:r,...i}=e[1];if(!s)throw new Error("address is required");return await ve(t,{...i,address:s})??null},queryKey:Ke(n)}}function Ke(t={}){return["balance",At(t)]}function ze(t,n={}){return{async queryFn({queryKey:e}){const s=n.abi;if(!s)throw new Error("abi is required");const{address:r,functionName:i,scopeKey:a,...u}=e[1];if(!r)throw new Error("address is required");if(!i)throw new Error("functionName is required");const l=u.args;return St(t,{abi:s,address:r,functionName:i,args:l,...u})},queryKey:Qe(n)}}function Qe(t={}){const{abi:n,...e}=t;return["readContract",At(e)]}function Ve(t){return{mutationFn(n){return Me(t,n)},mutationKey:["writeContract"]}}function qt(t){const n=N(()=>({...K(t),queryKeyHashFn:We})),e=te(n);return e.queryKey=K(n).queryKey,e}function Pt(t={}){const n=A(t),e=st(Ie(n)),s=Ae(n,{onChange(r){e.value=r}});return D(()=>s()),nt(e)}function ln(t={}){const n=N(()=>ct(t)),e=A(n),s=Pt({config:e}),r=N(()=>{const{address:i,chainId:a=s.value,query:u={}}=n.value,l=Fe(e,{...n.value,chainId:a}),o=!!(i&&(u.enabled??!0));return{...u,...l,enabled:o}});return qt(r)}function He(t={}){const n=A(t),e=st(Se(n)),s=Pe(n,{onChange(r){e.value=r}});return D(()=>s()),e}function dn(t={}){const{mutation:n}=t,e=A(t),s=Be(e),{mutate:r,mutateAsync:i,...a}=rt({...n,...s}),u=e.subscribe(({status:l})=>l,(l,o)=>{o==="connected"&&l==="disconnected"&&a.reset()});return D(()=>u()),{...a,connect:r,connectAsync:i,connectors:He({config:e}).value}}function Je(t={}){const n=A(t),e=st(_t(n)),s=qe(n,{onChange(r){e.value=r}});return D(()=>s()),nt(e)}function fn(t={}){const{mutation:n}=t,e=A(t),s=Je({config:e}),r=Te(e),{mutate:i,mutateAsync:a,...u}=rt({...n,...r});return{...u,connectors:N(()=>s.value.map(l=>l.connector)),disconnect:i,disconnectAsync:a}}function hn(t={}){const n=N(()=>ct(t)),e=A(n),s=Pt({config:e}),r=N(()=>{const{abi:i,address:a,chainId:u=s.value,functionName:l,query:o={}}=n.value,h=ze(e,{...n.value,chainId:u}),d=!!(a&&i&&l&&(o.enabled??!0));return{...o,...h,enabled:d,structuralSharing:o.structuralSharing??Ee}});return qt(r)}function pn(t={}){const{mutation:n}=t,e=A(t),s=Ve(e),{mutate:r,mutateAsync:i,...a}=rt({...n,...s});return{...a,writeContract:r,writeContractAsync:i}}Mt.type="walletConnect";function Mt(t){const n=t.isNewChainsStale??!0;let e,s;const r="eip155";let i,a,u,l,o,h;return d=>({id:"walletConnect",name:"WalletConnect",type:Mt.type,async setup(){const c=await this.getProvider().catch(()=>null);c&&(u||(u=this.onConnect.bind(this),c.on("connect",u)),o||(o=this.onSessionDelete.bind(this),c.on("session_delete",o)))},async connect({chainId:c,...m}={}){var w,b;try{const y=await this.getProvider();if(!y)throw new P;l||(l=this.onDisplayUri,y.on("display_uri",l));let C=c;if(!C){const p=await((w=d.storage)==null?void 0:w.getItem("state"))??{};d.chains.some(v=>v.id===p.chainId)?C=p.chainId:C=(b=d.chains[0])==null?void 0:b.id}if(!C)throw new Error("No chains found on connector.");const _=await this.isChainsStale();if(y.session&&_&&await y.disconnect(),!y.session||_){const p=d.chains.filter(g=>g.id!==C).map(g=>g.id);await y.connect({optionalChains:[C,...p],..."pairingTopic"in m?{pairingTopic:m.pairingTopic}:{}}),this.setRequestedChainsIds(d.chains.map(g=>g.id))}const I=(await y.enable()).map(p=>M(p)),f=await this.getChainId();return l&&(y.removeListener("display_uri",l),l=void 0),u&&(y.removeListener("connect",u),u=void 0),i||(i=this.onAccountsChanged.bind(this),y.on("accountsChanged",i)),a||(a=this.onChainChanged.bind(this),y.on("chainChanged",a)),h||(h=this.onDisconnect.bind(this),y.on("disconnect",h)),o||(o=this.onSessionDelete.bind(this),y.on("session_delete",o)),{accounts:I,chainId:f}}catch(y){throw/(user rejected|connection request reset)/i.test(y==null?void 0:y.message)?new j(y):y}},async disconnect(){const c=await this.getProvider();try{await(c==null?void 0:c.disconnect())}catch(m){if(!/No matching key/i.test(m.message))throw m}finally{a&&(c==null||c.removeListener("chainChanged",a),a=void 0),h&&(c==null||c.removeListener("disconnect",h),h=void 0),u||(u=this.onConnect.bind(this),c==null||c.on("connect",u)),i&&(c==null||c.removeListener("accountsChanged",i),i=void 0),o&&(c==null||c.removeListener("session_delete",o),o=void 0),this.setRequestedChainsIds([])}},async getAccounts(){return(await this.getProvider()).accounts.map(m=>M(m))},async getProvider({chainId:c}={}){var w;async function m(){const b=d.chains.map(C=>C.id);if(!b.length)return;const{EthereumProvider:y}=await se(()=>import("./@walletconnect-Cf5wJyuV.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37]));return await y.init({...t,disableProviderPing:!0,optionalChains:b,projectId:t.projectId,rpcMap:Object.fromEntries(d.chains.map(C=>[C.id,C.rpcUrls.default.http[0]])),showQrModal:t.showQrModal??!0})}return e||(s||(s=m()),e=await s,e==null||e.events.setMaxListeners(1/0)),c&&await((w=this.switchChain)==null?void 0:w.call(this,{chainId:c})),e},async getChainId(){return(await this.getProvider()).chainId},async isAuthorized(){try{const[c,m]=await Promise.all([this.getAccounts(),this.getProvider()]);return c.length?await this.isChainsStale()&&m.session?(await m.disconnect().catch(()=>{}),!1):!0:!1}catch{return!1}},async switchChain({addEthereumChainParameter:c,chainId:m}){var y,C,_;const w=await this.getProvider();if(!w)throw new P;const b=d.chains.find(I=>I.id===m);if(!b)throw new X(new Q);try{await Promise.all([new Promise(f=>{const p=({chainId:g})=>{g===m&&(d.emitter.off("change",p),f())};d.emitter.on("change",p)}),w.request({method:"wallet_switchEthereumChain",params:[{chainId:F(m)}]})]);const I=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...I,m]),b}catch(I){const f=I;if(/(user rejected)/i.test(f.message))throw new j(f);try{let p;c!=null&&c.blockExplorerUrls?p=c.blockExplorerUrls:p=(y=b.blockExplorers)!=null&&y.default.url?[(C=b.blockExplorers)==null?void 0:C.default.url]:[];let g;(_=c==null?void 0:c.rpcUrls)!=null&&_.length?g=c.rpcUrls:g=[...b.rpcUrls.default.http];const v={blockExplorerUrls:p,chainId:F(m),chainName:(c==null?void 0:c.chainName)??b.name,iconUrls:c==null?void 0:c.iconUrls,nativeCurrency:(c==null?void 0:c.nativeCurrency)??b.nativeCurrency,rpcUrls:g};await w.request({method:"wallet_addEthereumChain",params:[v]});const S=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...S,m]),b}catch(p){throw new j(p)}}},onAccountsChanged(c){c.length===0?this.onDisconnect():d.emitter.emit("change",{accounts:c.map(m=>M(m))})},onChainChanged(c){const m=Number(c);d.emitter.emit("change",{chainId:m})},async onConnect(c){const m=Number(c.chainId),w=await this.getAccounts();d.emitter.emit("connect",{accounts:w,chainId:m})},async onDisconnect(c){this.setRequestedChainsIds([]),d.emitter.emit("disconnect");const m=await this.getProvider();i&&(m.removeListener("accountsChanged",i),i=void 0),a&&(m.removeListener("chainChanged",a),a=void 0),h&&(m.removeListener("disconnect",h),h=void 0),o&&(m.removeListener("session_delete",o),o=void 0),u||(u=this.onConnect.bind(this),m.on("connect",u))},onDisplayUri(c){d.emitter.emit("message",{type:"display_uri",data:c})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){var m,w,b;return e?((b=(w=(m=e.session)==null?void 0:m.namespaces[r])==null?void 0:w.accounts)==null?void 0:b.map(y=>parseInt(y.split(":")[1]||"")))??[]:[]},async getRequestedChainsIds(){var c;return await((c=d.storage)==null?void 0:c.getItem(this.requestedChainsStorageKey))??[]},async isChainsStale(){if(!n)return!1;const c=d.chains.map(b=>b.id),m=this.getNamespaceChainsIds();if(m.length&&!m.some(b=>c.includes(b)))return!1;const w=await this.getRequestedChainsIds();return!c.every(b=>w.includes(b))},async setRequestedChainsIds(c){var m;await((m=d.storage)==null?void 0:m.setItem(this.requestedChainsStorageKey,c))},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}})}export{an as W,se as _,un as a,dn as b,fn as c,hn as d,pn as e,cn as f,it as i,ln as u,Mt as w};
