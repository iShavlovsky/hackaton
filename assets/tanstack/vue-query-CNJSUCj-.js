import{Q as x,M as P,a as S,i as A,b as I,c as $}from"../@tanstack-C0zlhh--.js";import{Z as D,u as V,_,i as T,f as F,x as R,R as w,w as p,j,$ as q,r as E}from"../@vue-DAVHC-O1.js";var K="VUE_QUERY_CLIENT";function M(e){const t=e?`:${e}`:"";return`${K}${t}`}function g(e,t){Object.keys(e).forEach(n=>{e[n]=t[n]})}function C(e,t){if(t){const n=t(e);if(n===void 0&&D(e)||n!==void 0)return n}if(Array.isArray(e))return e.map(n=>C(n,t));if(typeof e=="object"&&N(e)){const n=Object.entries(e).map(([u,s])=>[u,C(s,t)]);return Object.fromEntries(n)}return e}function r(e){return C(e,t=>{if(D(t))return r(V(t))})}function N(e){if(Object.prototype.toString.call(e)!=="[object Object]")return!1;const t=Object.getPrototypeOf(e);return t===null||t===Object.prototype}function m(e,t){return typeof e=="function"?e(...t):!!e}function U(e=""){if(!_())throw new Error("vue-query hooks can only be used inside setup() function or functions that support injection context.");const t=M(e),n=T(t);if(!n)throw new Error("No 'queryClient' found in Vue context, use 'VueQueryPlugin' to properly initialize the library.");return n}var k=class extends x{find(e){return super.find(r(e))}findAll(e={}){return super.findAll(r(e))}},L=class extends P{find(e){return super.find(r(e))}findAll(e={}){return super.findAll(r(e))}},Y=class extends S{constructor(e={}){const t={defaultOptions:e.defaultOptions,queryCache:e.queryCache||new k,mutationCache:e.mutationCache||new L};super(t),this.isRestoring=F(!1)}isFetching(e={}){return super.isFetching(r(e))}isMutating(e={}){return super.isMutating(r(e))}getQueryData(e){return super.getQueryData(r(e))}ensureQueryData(e){return super.ensureQueryData(r(e))}getQueriesData(e){return super.getQueriesData(r(e))}setQueryData(e,t,n={}){return super.setQueryData(r(e),t,r(n))}setQueriesData(e,t,n={}){return super.setQueriesData(r(e),t,r(n))}getQueryState(e){return super.getQueryState(r(e))}removeQueries(e={}){return super.removeQueries(r(e))}resetQueries(e={},t={}){return super.resetQueries(r(e),r(t))}cancelQueries(e={},t={}){return super.cancelQueries(r(e),r(t))}invalidateQueries(e={},t={}){return new Promise(n=>{setTimeout(async()=>{await super.invalidateQueries(r(e),r(t)),n()},0)})}refetchQueries(e={},t={}){return super.refetchQueries(r(e),r(t))}fetchQuery(e){return super.fetchQuery(r(e))}prefetchQuery(e){return super.prefetchQuery(r(e))}fetchInfiniteQuery(e){return super.fetchInfiniteQuery(r(e))}prefetchInfiniteQuery(e){return super.prefetchInfiniteQuery(r(e))}setDefaultOptions(e){super.setDefaultOptions(r(e))}setQueryDefaults(e,t){super.setQueryDefaults(r(e),r(t))}getQueryDefaults(e){return super.getQueryDefaults(r(e))}setMutationDefaults(e,t){super.setMutationDefaults(r(e),r(t))}getMutationDefaults(e){return super.getMutationDefaults(r(e))}},G={install:(e,t={})=>{const n=M(t.queryClientKey);let u;if("queryClient"in t&&t.queryClient)u=t.queryClient;else{const a="queryClientConfig"in t?t.queryClientConfig:void 0;u=new Y(a)}A||u.mount();let s=()=>{};if(t.clientPersister){u.isRestoring.value=!0;const[a,f]=t.clientPersister(u);s=a,f.then(()=>{var l;u.isRestoring.value=!1,(l=t.clientPersisterOnSuccess)==null||l.call(t,u)})}const i=()=>{u.unmount(),s()};if(e.onUnmount)e.onUnmount(i);else{const a=e.unmount;e.unmount=function(){i(),a()}}e.provide(n,u)}};function B(e,t,n){const u=U(),s=R(()=>{const o=r(t);typeof o.enabled=="function"&&(o.enabled=o.enabled());const y=u.defaultQueryOptions(o);return y._optimisticResults=u.isRestoring.value?"isRestoring":"optimistic",y}),i=new e(u,s.value),a=w(i.getCurrentResult());let f=()=>{};p(u.isRestoring,o=>{o||(f(),f=i.subscribe(y=>{g(a,y)}))},{immediate:!0});const l=()=>{i.setOptions(s.value),g(a,i.getCurrentResult())};p(s,l),j(()=>{f()});const c=(...o)=>(l(),a.refetch(...o)),h=()=>new Promise((o,y)=>{let d=()=>{};const b=()=>{if(s.value.enabled!==!1){i.setOptions(s.value);const v=i.getOptimisticResult(s.value);v.isStale?(d(),i.fetchOptimistic(s.value).then(o,O=>{m(s.value.throwOnError,[O,i.getCurrentQuery()])?y(O):o(i.getCurrentResult())})):(d(),o(v))}};b(),d=p(s,b)});p(()=>a.error,o=>{if(a.isError&&!a.isFetching&&m(s.value.throwOnError,[o,i.getCurrentQuery()]))throw o});const Q=q(E(a));for(const o in a)typeof a[o]=="function"&&(Q[o]=a[o]);return Q.suspense=h,Q.refetch=c,Q}function H(e,t){return B(I,e)}function J(e,t){const n=U(),u=R(()=>n.defaultMutationOptions(r(e))),s=new $(n,u.value),i=w(s.getCurrentResult()),a=s.subscribe(c=>{g(i,c)}),f=(c,h)=>{s.mutate(c,h).catch(()=>{})};p(u,()=>{s.setOptions(u.value)}),j(()=>{a()});const l=q(E(i));return p(()=>i.error,c=>{if(c&&m(u.value.throwOnError,[c]))throw c}),{...l,mutate:f,mutateAsync:i.mutate,reset:i.reset}}export{Y as Q,G as V,J as a,H as u};
