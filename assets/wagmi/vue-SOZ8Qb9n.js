import{h as w,B as P,g as x,w as A,a as E,b as I,c as W,d as v,e as B,f as q,i as D,j as M,k as F,l as K}from"../@wagmi-DKgSIdU4.js";import{u as g,_ as S,i as $,R as N,$ as Q,r as b,j as f,Z as h,x as l,f as m}from"../@vue-gYnbaL6f.js";import{u as R,a as y}from"../tanstack/vue-query-BbMLtNwm.js";const O=Symbol(),nn={install(t,e){const{config:n,reconnectOnMount:o=!0}=e;t.provide(O,n);const{onMount:s}=w(n,{...e,reconnectOnMount:o});s()}},T="0.0.10",U=()=>`@wagmi/vue@${T}`;class j extends P{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiError"})}get docsBaseUrl(){return"https://wagmi.sh/vue"}get version(){return U()}}class V extends j{constructor(){super("No `config` found in Vue context, use `WagmiPlugin` to properly initialize the library.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiPluginNotFoundError"})}}class k extends j{constructor(){super("Wagmi composables can only be used inside `setup()` function or functions that support injection context.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiInjectionContextError"})}}function H(t,e){Object.keys(t).forEach(n=>{t[n]=e[n]})}function r(t={}){const e=g(t);if(e.config)return e.config;if(!S())throw new k;const n=$(O);if(!n)throw new V;return n}function tn(t={}){const e=r(t),n=N(x(e)),o=A(e,{onChange(s){H(n,s)}});return f(()=>o()),Q(b(n))}function d(t,e){if(e){const n=e(t);if(n===void 0&&h(t)||n!==void 0)return n}if(Array.isArray(t))return t.map(n=>d(n,e));if(typeof t=="object"&&Z(t)){const n=Object.entries(t).map(([o,s])=>[o,d(s,e)]);return Object.fromEntries(n)}return t}function C(t){return d(t,e=>{if(h(e))return C(g(e))})}function Z(t){if(Object.prototype.toString.call(t)!=="[object Object]")return!1;const e=Object.getPrototypeOf(t);return e===null||e===Object.prototype}function _(t){const e=l(()=>({...g(t),queryKeyHashFn:E})),n=R(e);return n.queryKey=g(e).queryKey,n}function G(t={}){const e=r(t),n=m(I(e)),o=W(e,{onChange(s){n.value=s}});return f(()=>o()),b(n)}function en(t={}){const e=l(()=>C(t)),n=r(e),o=G({config:n}),s=l(()=>{const{address:a,chainId:i=o.value,query:u={}}=e.value,c=v(n,{...e.value,chainId:i}),p=!!(a&&(u.enabled??!0));return{...u,...c,enabled:p}});return _(s)}function J(t={}){const e=r(t),n=m(B(e)),o=q(e,{onChange(s){n.value=s}});return f(()=>o()),n}function on(t={}){const{mutation:e}=t,n=r(t),o=D(n),{mutate:s,mutateAsync:a,...i}=y({...e,...o}),u=n.subscribe(({status:c})=>c,(c,p)=>{p==="connected"&&c==="disconnected"&&i.reset()});return f(()=>u()),{...i,connect:s,connectAsync:a,connectors:J({config:n}).value}}function L(t={}){const e=r(t),n=m(M(e)),o=F(e,{onChange(s){n.value=s}});return f(()=>o()),b(n)}function sn(t={}){const{mutation:e}=t,n=r(t),o=L({config:n}),s=K(n),{mutate:a,mutateAsync:i,...u}=y({...e,...s});return{...u,connectors:l(()=>o.value.map(c=>c.connector)),disconnect:a,disconnectAsync:i}}export{nn as W,tn as a,on as b,sn as c,en as u};
