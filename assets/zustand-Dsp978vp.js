var _={VITE_BASE_URL:"/",VITE_API_URL:"https://а",BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const E=u=>(a,s,n)=>{const l=n.subscribe;return n.subscribe=(f,d,c)=>{let i=f;if(d){const h=(c==null?void 0:c.equalityFn)||Object.is;let m=f(n.getState());i=y=>{const S=f(y);if(!h(m,S)){const b=m;d(m=S,b)}},c!=null&&c.fireImmediately&&d(m,m)}return l(i)},u(a,s,n)},A=E;function R(u,a){let s;try{s=u()}catch{return}return{getItem:l=>{var e;const f=c=>c===null?null:JSON.parse(c,void 0),d=(e=s.getItem(l))!=null?e:null;return d instanceof Promise?d.then(f):f(d)},setItem:(l,e)=>s.setItem(l,JSON.stringify(e,void 0)),removeItem:l=>s.removeItem(l)}}const p=u=>a=>{try{const s=u(a);return s instanceof Promise?s:{then(n){return p(n)(s)},catch(n){return this}}}catch(s){return{then(n){return this},catch(n){return p(n)(s)}}}},w=(u,a)=>(s,n,l)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:r=>r,version:0,merge:(r,v)=>({...v,...r}),...a},f=!1;const d=new Set,c=new Set;let i;try{i=e.getStorage()}catch{}if(!i)return u((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),s(...r)},n,l);const h=p(e.serialize),m=()=>{const r=e.partialize({...n()});let v;const t=h({state:r,version:e.version}).then(g=>i.setItem(e.name,g)).catch(g=>{v=g});if(v)throw v;return t},y=l.setState;l.setState=(r,v)=>{y(r,v),m()};const S=u((...r)=>{s(...r),m()},n,l);let b;const o=()=>{var r;if(!i)return;f=!1,d.forEach(t=>t(n()));const v=((r=e.onRehydrateStorage)==null?void 0:r.call(e,n()))||void 0;return p(i.getItem.bind(i))(e.name).then(t=>{if(t)return e.deserialize(t)}).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var g;return b=e.merge(t,(g=n())!=null?g:S),s(b,!0),m()}).then(()=>{v==null||v(b,void 0),f=!0,c.forEach(t=>t(b))}).catch(t=>{v==null||v(void 0,t)})};return l.persist={setOptions:r=>{e={...e,...r},r.getStorage&&(i=r.getStorage())},clearStorage:()=>{i==null||i.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>o(),hasHydrated:()=>f,onHydrate:r=>(d.add(r),()=>{d.delete(r)}),onFinishHydration:r=>(c.add(r),()=>{c.delete(r)})},o(),b||S},H=(u,a)=>(s,n,l)=>{let e={storage:R(()=>localStorage),partialize:o=>o,version:0,merge:(o,r)=>({...r,...o}),...a},f=!1;const d=new Set,c=new Set;let i=e.storage;if(!i)return u((...o)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),s(...o)},n,l);const h=()=>{const o=e.partialize({...n()});return i.setItem(e.name,{state:o,version:e.version})},m=l.setState;l.setState=(o,r)=>{m(o,r),h()};const y=u((...o)=>{s(...o),h()},n,l);let S;const b=()=>{var o,r;if(!i)return;f=!1,d.forEach(t=>{var g;return t((g=n())!=null?g:y)});const v=((r=e.onRehydrateStorage)==null?void 0:r.call(e,(o=n())!=null?o:y))||void 0;return p(i.getItem.bind(i))(e.name).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var g;return S=e.merge(t,(g=n())!=null?g:y),s(S,!0),h()}).then(()=>{v==null||v(S,void 0),S=n(),f=!0,c.forEach(t=>t(S))}).catch(t=>{v==null||v(void 0,t)})};return l.persist={setOptions:o=>{e={...e,...o},o.storage&&(i=o.storage)},clearStorage:()=>{i==null||i.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>b(),hasHydrated:()=>f,onHydrate:o=>(d.add(o),()=>{d.delete(o)}),onFinishHydration:o=>(c.add(o),()=>{c.delete(o)})},e.skipHydration||b(),S||y},D=(u,a)=>"getStorage"in a||"serialize"in a||"deserialize"in a?((_?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),w(u,a)):H(u,a),L=D;var U={VITE_BASE_URL:"/",VITE_API_URL:"https://а",BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const I=u=>{let a;const s=new Set,n=(c,i)=>{const h=typeof c=="function"?c(a):c;if(!Object.is(h,a)){const m=a;a=i??typeof h!="object"?h:Object.assign({},a,h),s.forEach(y=>y(a,m))}},l=()=>a,d={setState:n,getState:l,subscribe:c=>(s.add(c),()=>s.delete(c)),destroy:()=>{(U?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),s.clear()}};return a=u(n,l,d),d},O=u=>u?I(u):I;export{O as c,L as p,A as s};
